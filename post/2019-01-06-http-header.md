# HTTP Header

## HTTP Header 종류

- General header : 요청 및 응답에 적용된다. 데이터와 직접적인 관련은 없다.
- Request header : 요청할 리소스와 클라이언트 정보가 포함되어 있다.
- Response header : 응답에 관한 추가 정보가 포함되어 있다.
- Entity header : 엔티티 정보에 대한 추가 정보가 포함되어 있다. 

## 프록시를 처리에 대한 분류

## 1. end to end

- 최종 수신자에게 전달되어야 한다. 
- 프록시는 수정되지 않은 해당 정보를 재전송 한다. 
- 캐시는 해당 정보를 가지고 있다.

## 2. hop by hop

- 단일 전송에 대해서만 의미가 있다. 
- Connection, Keep-Alive, Authenticate, Proxy-Athorization, TE, Trailer, Transfer-Encoding, Upgrade이 포함된다. 

## HTTP Authentication

- HTTP는 액세스 인증과 제어를 위한 프레임워크를 제공한다. 
- 가장 일반적인 방식으로 "Basic"방식을 이용한다. 

## 일반적인 HTTP 인증 프레임워크

- RFC7235는 서버에 의해 클라이언트 요청을 시도하고, 클라이언트에 의해 인증정보를 제공하기 위해 사용될 수 있는 HTTP 인증 프레임워크를 정의한다. 
- 서버는 클라이언트에서 401 응답 코드를 가지고 응답하며, 최소한 한번의 시도에 포함된 WWW-Authenticate 응답 헤더로 권한을 부여하는 방법에 대한 정보를 제공한다. 
- 서버와 인증을 하기 원하는 클라이언트는 Authorization 요청 헤드 필더에 인증 정보를 포함함으로써 인증을 수행할 수 있다. 
- 클라이언트는 대개 사용자에게 비밀번호 프롬프트를 표시할 것이고 정확한 Authorization 헤더를 포함하는 요청을 만들 것이다. 
- Basic 인증일 경우, 교환의 안전을 위해 HTTPS(TLS) 연결 위에서 발생하여야 한다. 

## 프록시 인증

- 동일한 시도 및 응답 매커니즘이 프록시 인증을 위해서도 사용될 수 있다. 
- 이 경우, 이것은 인증을 요구하는 중간 프록시이다. 
- 리소스 인증 및 프록시 인증은 함께 존재할 수 있기 때문에, 헤더와 상태 코드의 다른 세트가 필요하다.
- 프록시의 경우 요청에 대한 상태 코드는 407이고, Proxy-Authonticate 응답 헤더는 프록시에 적용 가능한 최소한 하나의 요청을 포함하며, Proxy-Authorization 요청 헤더는 프록시 서버에 인증 정보를 제공하기 위해 사용된다. 

## 접근 거부

- (프록시)서버가 주어진 리소스에 대한 접근 권한을 얻기 위해 적절하지 않은 유효한 인증 정보를 수신한다면, 서버는 403 상태 코드로 응답하여야 한다. 
- 401, 407과 다르게 해당 사용자에 대한 인증은 불가능하다.

## WWW-Authenticate와 Proxy-Athenticate헤더

- WWW-Authenticate와 Proxy-Athenticate 응답 헤더는 자원에 대한 엑세스를 얻기 위해 사용되어야 할 인증 방법을 정의한다. 
- 이들은 인증을 하려는 클라이언트가 인증 정보를 제공할 방법을 알기 위해, 어떤 인증 스킴이 사용될 것인지를 구체적으로 적을 필요가 있다. 

## Authorization과 Proxy-Authorization헤더

- Authorization과 Proxy-Authorization 요청 헤더는 사용자 에이전트가 (프록시) 서버에 인증을 하기 위한 인증 정보를 포함한다. 
- 여기에서 type은 다시 한 번 필요하며 credentials이 뒤에 따라온다.
- credentials 부분은 어떤 인증 스킴이 사용되는지에 따라 인코딩이 되어 있거나 암호화가 되어 있을 수 있다. 

## Basic 인증 스킴

- base64를 이용하여 인코딩된 사용자 ID/비밀번호 쌍의 인증 정보를 전달한다. 

## Basic 인증의 보안

- 사용자 ID와 비밀번호가 평문으로 네트워크를 통해 전달되기 때문에, Basic 인증 스킴은 안전하지 않다. 
- HTTPS/TLS는 basic 인증과 함께 사용되어야 한다. 
- 이러한 추가적인 보안상의 향상이 없이는, basic 인증은 민감하거나 귀중한 정보를 보호하는데 사용되서는 안된다. 


## Authentication headers

## 1. WWW-Authenticate

- response header
- 리소스에 접근하는데 필요한 인증 메소드를 정의한다. 
- 함께 전송되는 응답은 401 Unauthorized response이다. 

~~~
// Syntax

WWW-Authenticate: <type> realm=<realm> charset = <charset>
~~~

- '<type>'은 인증 유형이며 기본 값은 Basic이다.
- 'realm=<realm>'은 protected area에 대한 설명이다. 정의되어 있지 않다면 hostname이 표시된다. 또한 어떤 공간에 사용자가 접근하려고 시도하는지 알리기 위하여, "중간 단계의 사이트에 대한 접근"과 같거나 또는 비슷한 메시지가 될 수 있다. 
- 'charset = <charset>'은 사용자 이름과 암호를 제출할 때 서버가 선호하는 인코딩 체계를 알린다. 허용되는 유일한 값은 'UTF-8'이다.

~~~
//Example

WWW-Authenticate: Basic

WWW-Authenticate: Basic realm="Access to the staging site", charset="UTF-8"
~~~

## 2. Authorization

- request header
- 서버의 사용자 에이전트임을 증명하는 자격을 포함하며, 보통 401 Unauthorized 상태를 WWW-Authenticate에 알려준 이후에 나온다. 

~~~
// Syntax

Authorization: <type> <credentials>
~~~

- '<type>'은 인증 타입이다. 보통 타입은 Basic이다. 
- '<credentials>'은 만약 type으로 Basic이 사용되었다면 증명은 다음과 같다.
    - 사용자 명과 비밀번호가 콜론을 이용하여 합쳐진다. 
    - 그 결과를 문자열에 base64로 인코딩한다.(base64는 문자를 그대로 보내는 것과 같다. )

~~~
// Example

Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
~~~

## 3. Proxy-authenticate

- response header
- 프록시 서버 뒤의 리소스에 엑세스하는 데 사용해야하는 인증 방법을 정의한다. 
- 407 Proxy Authentication Required가 함께 전송된다. 

~~~
// Syntax

Proxy-Authenticate: <type> realm=<realm>
~~~

- '<type>'은 인증 유형이다. 기본 타입은 Basic이다. 
- 'realm=<realm>'은 protected area에 대한 설명이다. 정의되어 있지 않다면 hostname이 표시된다. 

~~~
// Example

Proxy-Authenticate: Basic

Proxy-Authenticate: Basic realm="Access to the internal site"
~~~

## 4 Proxy-Authorization

- Request header
- 프록시 서버에서의 사용자 에이전트 자격 증명에 대한 내용을 포함한다. 
- 보통 Proxy-authenticate 헤더와 407 Authentication Requred가 서버로부터 응답된 이후에 나타난다. 

~~~
// Syntax

Proxy-Authorization: <type> <credentials>
~~~

- '<type>'은 인증 유형이다. 기본 타입은 Basic이다. 
- '<credentials>'은 만약 type으로 Basic이 사용되었다면 증명은 다음과 같다.
    - 사용자 명과 비밀번호가 콜론을 이용하여 합쳐진다. 
    - 그 결과를 문자열에 base64로 인코딩한다.(base64는 문자를 그대로 보내는 것과 같다. )

## Cashing

- 웹 사이트와 애플리케이션의 성능은 이전에 가져온 리소스들을 재사용함으로써 현저하게 향상될 수 있다. 
- 웹 캐시는 레이턴시와 네트워크 트래칙을 줄여주므로 리소스의 표현에 필요로 하는 시간을 줄인다. 
- HTTP 캐시 사용을 활용하여, 웹 사이트를 좀 더 잘 반응하도록 만들 수 있다. 

## 다른 종류의 캐시들

- 캐싱은 주어진 리소스의 복사본을 저장하고 요청 시에 그것을 서브하는 기술이다. 
- 웹 캐시가 자신의 저장소 내의 요청된 리소스를 가지고 있다면, 요청을 가로채 원래의 서버로부터 리소스를 다시 다운로드하는 대신 리소스의 복사본을 반환한다. 
- 이것은 다음과 같은 몇 가지 목표를 달성하게 해준다.
    - 모든 클라이언트를 서브할 필요가 없어진 서버의 로드량이 여유로워진다.
    - 클라이언트에 더 가까워지게 되므로 성능이 향상된다. 
    - 리소스를 회신하는데 더 적은 비용이 들게 된다. 
    - 하나의 웹 사이트에 대해, 캐싱이 높은 성능 달성에 중요한 컴포넌트이다.
    - 리소스는 영원히 변하지 않는 것이 아니므로 캐시 자원을 변하기 전까지 유지하는 것이 중요하다.

- 캐시에는 몇 가지 종류가 있으며 크게 두 분류로 묶을 수 있다. 
    1. 사설 브라우저 캐시
    2. 공유 프록시 캐시
    이외에도 게이트웨이 캐시, CDN, 리버스 프록시 캐시 그리고 로드 밸랜서 등이 있다. 

## 1. 사설 브라우저 캐시

- 단일 사용자에게 초점이 맞춰져 있다. 
- 브라우저 캐시는 사용자에 의하여 HTTP를 통해 다운로드된 모든 문서들을 가지고 있다. 
- 서버에 대한 추가적인 요청없이 뒤로 가거나 앞으로 가기, 저장, 소스로 보기 등을 위해 이용 가능한 방문했던 문서들을 만드는데 사용된다. 
- 캐시된 컨텐츠의 오프라인 브라우징을 개선시킨다. 

## 2. 공유 프록시 캐시

- 한 명 이상의 사용자에 의해 재사용되는 응답을 저장하는 캐시이다. 
- 예를 들어, 당신의 회사의 ISP는 많은 사용자들을 서브하기 위해 지역 네트워크 기반의 일부분으로써 웹 프록시를 설치해뒀을 수도 있는데, 그 덕분에 조회가 많이 되는 리소스들은 몇 번이고 재사용되어 네트워크 트래픽과 레이턴시를 줄여준다. 

## 캐싱 동작의 대상

- HTTP 캐싱은 부가적이지만 캐시된 리소스를 재상용하는 것은 보통 바람직한 일이다. 
- 하지만, 일반적인 HTTP 캐시들은 GET에 대한 응답을 캐싱하는 것으로 제한되며 다른 메서드들은 제외될 것이다.
- 일차 캐시 키는 요청 매서드 그리고 대상 URI로 구성된다.(종종 GET 요청으로만 사용되는 URI만이 캐싱의 대상이 되곤한다.)
- 일반적인 캐싱 엔트리의 폼은 다음과 같다.
    - 검색 요청의 성공적인 결과: HTML 문서, 이미지 록은 파일과 같은 리소스를 포함하는 GET 요청에 대한 200 (OK)응답
    - 영구적인 리다이렉트: 301(영구적으로 이동된) 응답
    - 오류 응답: 404(찾을 수 없음) 결과 페이지
    - 완전하지 않은 결과: 206(부분적인 컨텐츠) 응답
    - 캐시 키로 사용하기에 적절한 무언가가 정의된 경우의 GET 이외의 응답
- 캐시 엔트리는 요청이 컨텐츠 협상의 대상인 경우, 두번째 키에 의해 구별되는 다중 저장 응답으로 구성되어 있을 것이다. 

## 캐싱 제어

## 1. Cache-control 헤더
- Cache-Control HTTP/1.1 기본 헤더 필드는 요청과 응답 양측 모두에 있어 캐싱 메커니즘을 위한 디렉티브를 지정하는데 사용된다.
- 그것이 제공하는 여러 디렉티브들로 캐싱 정책을 정의하고자 한다면 이 헤더를 사용해야 한다.

### 캐시 스토리지 전혀 없음

- 캐시는 클라이언트 요청 혹은 서버 응답에 관해서 어떤 것도 저장해서는 안된다. 
- 요청은 서버 측으로 전송되고 전체 응답은 매번 그리고 항상 다운로드 한다. 

~~~
Cache-Control: no-store
Cache-Control: no-cache, no-store, must-revalidate
~~~

### 캐시하지 않음

- 캐시된 복사본을 사용자에게 보여주기 전에, 재검증을 위해 원 서버로 요청을 보낸다. 

~~~
Cache-Control: no-cache
~~~

### 사설 캐시와 공개 캐시

- '공개' 디렉티브는 응답이 어떤 캐시에 의해서든 캐시된다는 것을 가리킨다. 
- 이것은 HTTP 인증 혹은 보통 캐시 가능하지 않은 응답 상태 코드를 지닌 페이지가 캐시되어야 할 경우 유용할 수 있다. 
- 반면 "사설"은 응답이 단일 사용자를 위한 것이며 공유 캐시에 의해 저장되어서는 안된다는 것을 가리킨다. 

~~~
Cache-Control: private
Cache-Control: public
~~~

### 만료

- 여기서 가장 중요한 디렉티브는 "max-age=<second>"로 리소스가 유효하다고 판단되는 최대 시간을 말한다. 
- Expires와는 다르게, 이 디렉티브는 요청 시간과 관련이 있다. 
- 변경되지 않을 애플리케이션 내 파일에 대해, 보통 공격적인 캐싱을 추가할 수 있다. 
- 이것은 이미지, CSS 파일 그리고 자바스크립트 파일과 같은 정적 파일들을 포함한다. 

~~~
Cache-Control: max-age=31536000
~~~

### 검증

- 'must-revalidate' 디렉티브 사용 시, 캐시는 그것을 사용하기 이전의 오래된 리소스의 상태와 만료된 리소스가 사용되지 않았다는 것을 확실히 해두어야 한다. 

~~~
Cache-Control: must-revalidate
~~~

## 2. Pragma 헤더

- Pragma는 HTTP/1.0헤더로, HTTP 응답에 대해 특정되지 않으므로, Cache-Control 헤더 필드가 요청 내에서 생략되지 않은 경우, Cache-Control: no-cache와 동일하게 동작할지라고 일반적인 HTTP/1.1 Cache-Control 헤더에 대해 신뢰할 만한 대체 헤더는 아니다. 
- 하위 호완의 경우에만 사용할 것

## 유효함

- 리소스가 캐시 내에 저장되고 나면, 이론적으로는 영원히 캐시에 의해 서버될 수도 있다. 
- 캐시는 한정적인 캐시를 가지므로 아이템을은 주기적으로 스토리지에서 제거된다. 
- 이런 과정을 캐시 축출이라고 한다. 
- HTTP가 클라이언트-서버 프로토콜이므로, 리소스가 변경되었을 때 서버는 캐시와 클라이언트에 접근할 수 없다. 
- 그들은 리소스에 대한 만료 시간을 주고 받아야 한다. 
- 해당 만료 시간 이전에는, 리소스가 유효하다.
- 만료 시간 이후의 리소스는 실효된다. 
- 축출 알고리즘은 대게 실효된 리소스 이상의 권한을 유효한 리소스에게 준다. 
- 실효된 리소스는 축출되거나 무시되지 않는다. 
- 캐시가 실효된 리소스에 대한 요청을 받은 경우, 아직 유효한지 아닌지를 검사하기 위해 If-None-Match와 함께 전송한다. 
- 만약 그렇다면, 서버는 요청된 리소스 본문을 전송하지 않고 304 헤더를 돌려보내 대역폭을 절약한다. 
- 유효 수명은 몇가지 헤더에 근거해 계산된다. 
- "Cache-control: max-age=N" 헤더가 특정된 경우, 유효 수명은 N과 동일하다. 
- 만약 이 헤더가 없다면, Expires 헤더의 유무를 검사한다. 
- 존재한다면 그것의 값에서 Date 헤더의 값을 뺀 결과가 유효 수명이 된다. 
- 마지막으로, 그 헤더도 없다면, Last-Modified 헤더를 찾게된다.
- 이 헤더가 있다면, 캐시의 유효 수명은 Date 헤더 값에서 Last-modified 헤더 값을 뺀 값을 10으로 나눈 결과가 된다. 

~~~
expirationTime = responseTime(브라우저가 수신한 시간) + freshnessLifetime - currentAge
~~~

## 활성화된(Revved) 리소스

- 우리가 캐시된 리소스를 사용하면 사용할 수록, 웹 사이트의 응답성과 성능은 점점 더 조아질 것이다. 
- 이것을 최적화하기 위해 실제 방법은 만료 시간을 가능한 더 먼 미래로 설정하는 것이다. 
- 이것은 리소스를 정기적으로 혹은 자주 갱신함으로써 가능하지만, 아무 드물게 업데이트되는 리소스의 경우에는 이게 문제가 된다.
- 이런 리소스들은 캐시한 리소스로부터 최대한 활용되는 리소스들로, 앞서 얘기한 방법 덕분에 이러한 리소스들을 갱신하기 더 어렵게 된다. 
- 이것은 각 웹 페이지에 포함되고 링크된 기술적인 리소스들을 대표한다: 자바스크립트와 css 파일들의 변경은 드물지만, 그들이 변경될 때 빠르게 갱신되기를 원할 것이다. 

- 웹 개발자들은 Steve Sounders가 revving이라고 불렀던 기술을 발명했다.
- 드물게 업데이트되는 파일들은 명확한 방법으로 이름이 지어진다: 보통은 파일 이름인, 파일들의 URL에 수정(혹은 버전) 번호가 추가된다. 
- 그와 같이 해당 리소스의 각각의 새로운 수정본은 결코 변경되지 않으며 보통은 1년 혹은 그 이상의 아주 먼 미래에 만료될 수 있는 그 자체로 리소스로써 간주된다. 
- 새로운 버전들을 가지기 위해, 해당 리소스들과의 모든 연결은 모두 변경되어야 하며, 그것이 이 방법의 단점이다.: 이것은 보통 웹 개발자들이 사용하는 툴체인에 의해 다루어지는 추가적인 복잡함이다. 
- 드물게 변경되는 리소스들이 변경되는 경우 자주 변경되는 리소스에 추가적인 변화를 초래한다. 이런 리소스들이 읽혀지는 경우, 다른 리소스들의 새로운 버전들도 읽혀지게 된다. 

- 이 기술은 추가적인 이점도 가지고 있다: 동시에 캐시된 두 개의 리소스를 갱신하는 것은 한 리소스의 기한이 지난 버전이 다른 리소스의 새로운 버전과 함계 혼합되어 사용되는 경우를 초래할 것이다. 
- 이것은 웹 사이트가 상호 간의 의존성을 가지고 있는 CSS 스타일시트와 자바스크립트를 가지고 있는 경우 매우 중요하다. 

- 즉, 캐시를 최대한 활용하는 방법은 만료시간을 늘리는 것이다. 하지만 만료기간을 늘림으로 변경을 바로 보고 싶은 리소스의 경우 문제가 생길 수 있다. 변경이 드물지만 수정이 일어났을때 결과를 빨리 보고 싶을때 문제가 발생한다. 각 파일들에 버전 번호를 부여하여 업데이트를 관리한다.

## 캐시 검증

- 재검증은 사용자가 리로드 버튼을 누를 경우 촉발된다. 
- 재검증은 캐시된 응답이 "Cache-control: must-revalidate" 헤더를 포함하고 있는 경우 일반적인 브라우징 상태에서 촉발되기도 한다. 
- 또 다른 요인은 Advanced->Cache 환경설정 패널 내에 캐시 검증 환경 설정이다. 
- 거기에는 문서가 로드될 때마다 검증을 강제할 수 있는 옵션이 있다. 

- 캐시된 문서의 만료 시간이 가까워져오면, 문서가 검증되거나 가시 불러오게 된다. 
- 검증은 서버가 강한 검증 혹은 약한 검증 중 하나라도 제공하는 경우에만 일어날 수 있다. 

## 1. ETags

- ETag 응답 헤더는 강한 검증으로써 사용될 수 있는 사용자 에이전트에게 있어 불분명한 값이다. 
- 그것은 브라우저와 같은 HTTP 사용자 에이전트가 이 문자열이 무엇을 표현하는지 알 수 없고 그것의 값이 무엇이 될지를 예측할 수 없다는 것을 의미한다. 
- ETag 헤더가 리소스에 대한 응답의 일부라면, 클라이언트는 이후 요청의 헤더 내에(캐시된 응답을 검증하기 위해) If-None-Match 헤더를 발급할 수 있다. 

- Last-Modified 응답 헤더는 약한 검증으로써 사용될 수 있다. 
- 그것이 1초의 해상도만 가질 수 있기에 약하다고 간주된다. 
- Last-Modified 헤더가 응답 내에 나타나면 클라이언트는 캐시된 문서를 검증하기 위해 If-Modified-Since 요청 헤더를 발급할 수 있다. 

- 검증 요청이 이루어지면, 서버는 검증 요청을 일반적인 200 ok으로 요청과 응답을 무시하거나 브라우저에게 캐시된 복사본을 사용하도록 지시하기 위해 304 Not Modified(본문을 비워둔 상태로)를 반환할 수 있다. 
- 후자의 응답은 캐시된 문서의 만료 시간을 갱신하는 헤더를 포함할 수도 있다. 

## 상황에 따른 응답

- Vary HTTP 응답 헤더는 원 서버로부터 신선한 리소스를 요청하지 않고 캐시된 응답이 사용될 수 있는지를 결정하기 위해 이후의 요청 헤더를 일치시키는 방식을 결정한다. 
- 캐시가 Vary 헤더 필드를 지닌 캐시된 응답에 의해 만족될 수 있는 요청을 수신한 경우, Vary 헤더에 의해 지명된 모든 헤더 필드들이 원래의 (캐시된) 요청과 새로운 요청 모두와 일치하지 않는다면 그 캐시된 응답을 사용해서는 안된다. 

- 예를 들면, 이것은 컨텐츠를 동적으로 서브하는 경우에 유용할 수 있다. 
- Vary: User-Agent 헤더가 사용되는 경우, 캐싱 서버는 캐시로부터 페이지를 서브래야 할지를 결정할 때 사용자 에이전트를 고려해야 한다. 
- 만약 당신이 모바일 사용자에게 다른 컨텐츠를 서브하고 있다면, 그 헤더는 캐시가 모바일 사용자에게 사이트의 데스크톱 버전을 실수로 서브하는 일을 피하도록 도와줄 것이다. 
- 추가로, 구글과 다른 검색 엔진들이 페이지의 모바일 버전을 찾는데 도움을 줄 수 있으며, 그들에게 클로킹이 의도되지 않았다는 것을 알려준다

~~~
Vary: User-Agent
~~~

- User-Agent 헤더 값은 모바일과 데스크톱 클라이언트에 따라 다르므로, 캐시는 모바일 컨텐츠를 데스크톱 사용자에게 혹은 그 반대의 경우라도 실수로 서브하지 않을 것이다. 


## 1. age

- Response header
- 프록시 캐시 내에 초당 머무르는 시간을 나타낸다. 
